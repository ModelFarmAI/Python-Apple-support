--- a/Python/dynload_shlib.c
+++ b/Python/dynload_shlib.c
@@ -38,12 +38,13 @@
 #ifdef __CYGWIN__
     ".dll",
 #else  /* !__CYGWIN__ */
-    "." SOABI ".so",
+    "." SOABI ".so", "." SOABI ".dylib",
 #ifdef ALT_SOABI
-    "." ALT_SOABI ".so",
+    "." ALT_SOABI ".so", "." ALT_SOABI ".dylib",
 #endif
     ".abi" PYTHON_ABI_STRING ".so",
-    ".so",
+    ".abi" PYTHON_ABI_STRING ".dylib",
+    ".so", ".dylib",
 #endif  /* __CYGWIN__ */
     NULL,
 };
--- /dev/null
+++ b/Lib/_ios_support.py
@@ -0,0 +1,36 @@
+from ctypes import cdll, c_void_p, c_char_p
+from ctypes import util
+
+
+def get_platform_ios():
+    objc = cdll.LoadLibrary(util.find_library(b'objc'))
+
+    objc.objc_getClass.restype = c_void_p
+    objc.objc_getClass.argtypes = [c_char_p]
+    objc.objc_msgSend.restype = c_void_p
+    objc.objc_msgSend.argtypes = [c_void_p, c_void_p]
+    objc.sel_registerName.restype = c_void_p
+    objc.sel_registerName.argtypes = [c_char_p]
+
+    UIDevice = c_void_p(objc.objc_getClass(b'UIDevice'))
+    SEL_currentDevice = c_void_p(objc.sel_registerName(b'currentDevice'))
+    device = c_void_p(objc.objc_msgSend(UIDevice, SEL_currentDevice))
+
+    SEL_systemVersion = c_void_p(objc.sel_registerName(b'systemVersion'))
+    systemVersion = c_void_p(objc.objc_msgSend(device, SEL_systemVersion))
+
+    SEL_systemName = c_void_p(objc.sel_registerName(b'systemName'))
+    systemName = c_void_p(objc.objc_msgSend(device, SEL_systemName))
+
+    SEL_model = c_void_p(objc.sel_registerName(b'model'))
+    systemModel = c_void_p(objc.objc_msgSend(device, SEL_model))
+
+    # UTF8String returns a const char*;
+    SEL_UTF8String = c_void_p(objc.sel_registerName(b'UTF8String'))
+    objc.objc_msgSend.restype = c_char_p
+
+    system = objc.objc_msgSend(systemName, SEL_UTF8String).decode()
+    release = objc.objc_msgSend(systemVersion, SEL_UTF8String).decode()
+    model = objc.objc_msgSend(systemModel, SEL_UTF8String).decode()
+
+    return system, release, model
diff --git a/Lib/ctypes/util.py b/Lib/ctypes/util.py
index 0c2510e161..6c3c43f11d 100644
--- a/Lib/ctypes/util.py
+++ b/Lib/ctypes/util.py
@@ -67,7 +67,7 @@
                 return fname
         return None
 
-elif os.name == "posix" and sys.platform == "darwin":
+elif os.name == "posix" and sys.platform in ('darwin', 'ios', 'tvos', 'watchos'):
     from ctypes.macholib.dyld import dyld_find as _dyld_find
     def find_library(name):
         possible = ['lib%s.dylib' % name,
diff --git a/Lib/distutils/tests/test_build_ext.py b/Lib/distutils/tests/test_build_ext.py
index 8e7364d2a2..eec325fecc 100644
--- a/Lib/distutils/tests/test_build_ext.py
+++ b/Lib/distutils/tests/test_build_ext.py
@@ -15,7 +15,7 @@
 
 import unittest
 from test import support
-from test.support import os_helper
+from test.support import os_helper, has_subprocess_support
 from test.support.script_helper import assert_python_ok
 
 # http://bugs.python.org/issue4373
@@ -56,6 +56,7 @@
     def build_ext(self, *args, **kwargs):
         return build_ext(*args, **kwargs)
 
+    @unittest.skipUnless(has_subprocess_support, "distutils cannot spawn child processes")
     def test_build_ext(self):
         cmd = support.missing_compiler_executable()
         if cmd is not None:
@@ -332,6 +333,7 @@
         cmd.run()
         self.assertEqual(cmd.compiler, 'unix')
 
+    @unittest.skipUnless(has_subprocess_support, "distutils cannot spawn child processes")
     def test_get_outputs(self):
         cmd = support.missing_compiler_executable()
         if cmd is not None:
diff --git a/Lib/distutils/tests/test_build_py.py b/Lib/distutils/tests/test_build_py.py
index 0712e92c6a..4c05e8d968 100644
--- a/Lib/distutils/tests/test_build_py.py
+++ b/Lib/distutils/tests/test_build_py.py
@@ -9,7 +9,7 @@
 from distutils.errors import DistutilsFileError
 
 from distutils.tests import support
-from test.support import run_unittest
+from test.support import run_unittest, has_subprocess_support
 
 
 class BuildPyTestCase(support.TempdirManager,
@@ -106,6 +106,7 @@
                          ['boiledeggs.%s.pyc' % sys.implementation.cache_tag])
 
     @unittest.skipIf(sys.dont_write_bytecode, 'byte-compile disabled')
+    @unittest.skipUnless(has_subprocess_support, "distutils cannot spawn child processes")
     def test_byte_compile_optimized(self):
         project_dir, dist = self.create_dist(py_modules=['boiledeggs'])
         os.chdir(project_dir)
diff --git a/Lib/distutils/tests/test_config_cmd.py b/Lib/distutils/tests/test_config_cmd.py
index 0127ba71fc..d03356af1b 100644
--- a/Lib/distutils/tests/test_config_cmd.py
+++ b/Lib/distutils/tests/test_config_cmd.py
@@ -3,7 +3,7 @@
 import os
 import sys
 import sysconfig
-from test.support import run_unittest, missing_compiler_executable
+from test.support import run_unittest, missing_compiler_executable, has_subprocess_support
 
 from distutils.command.config import dump_file, config
 from distutils.tests import support
@@ -42,6 +42,7 @@
         self.assertEqual(len(self._logs), numlines+1)
 
     @unittest.skipIf(sys.platform == 'win32', "can't test on Windows")
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def test_search_cpp(self):
         cmd = missing_compiler_executable(['preprocessor'])
         if cmd is not None:
diff --git a/Lib/distutils/tests/test_cygwinccompiler.py b/Lib/distutils/tests/test_cygwinccompiler.py
index 9dc869de4c..9a1b18aba9 100644
--- a/Lib/distutils/tests/test_cygwinccompiler.py
+++ b/Lib/distutils/tests/test_cygwinccompiler.py
@@ -5,11 +5,14 @@
 from io import BytesIO
 from test.support import run_unittest
 
-from distutils import cygwinccompiler
-from distutils.cygwinccompiler import (check_config_h,
-                                       CONFIG_H_OK, CONFIG_H_NOTOK,
-                                       CONFIG_H_UNCERTAIN, get_versions,
-                                       get_msvcr)
+# Importing cygwinccompiler attempts to import other tools
+# that may not exist unless you're on win32.
+if sys.platform == 'win32':
+    from distutils import cygwinccompiler
+    from distutils.cygwinccompiler import (check_config_h,
+                                           CONFIG_H_OK, CONFIG_H_NOTOK,
+                                           CONFIG_H_UNCERTAIN, get_versions,
+                                           get_msvcr)
 from distutils.tests import support
 
 class FakePopen(object):
@@ -25,6 +28,7 @@
             self.stdout = os.popen(cmd, 'r')
 
 
+@unittest.skipUnless(sys.platform == "win32", "These tests are only for win32")
 class CygwinCCompilerTestCase(support.TempdirManager,
                               unittest.TestCase):
 
diff --git a/Lib/distutils/tests/test_install.py b/Lib/distutils/tests/test_install.py
index 0632024b35..a21962792b 100644
--- a/Lib/distutils/tests/test_install.py
+++ b/Lib/distutils/tests/test_install.py
@@ -5,7 +5,7 @@
 import unittest
 import site
 
-from test.support import captured_stdout, run_unittest
+from test.support import captured_stdout, run_unittest, has_subprocess_support
 
 from distutils import sysconfig
 from distutils.command.install import install, HAS_USER_SITE
@@ -208,6 +208,7 @@
                     'UNKNOWN-0.0.0-py%s.%s.egg-info' % sys.version_info[:2]]
         self.assertEqual(found, expected)
 
+    @unittest.skipUnless(has_subprocess_support, "distutils cannot spawn child processes")
     def test_record_extensions(self):
         cmd = test_support.missing_compiler_executable()
         if cmd is not None:
diff --git a/Lib/distutils/tests/test_install_lib.py b/Lib/distutils/tests/test_install_lib.py
index fda6315bbc..121664b722 100644
--- a/Lib/distutils/tests/test_install_lib.py
+++ b/Lib/distutils/tests/test_install_lib.py
@@ -8,7 +8,7 @@
 from distutils.extension import Extension
 from distutils.tests import support
 from distutils.errors import DistutilsOptionError
-from test.support import run_unittest
+from test.support import run_unittest, has_subprocess_support
 
 
 class InstallLibTestCase(support.TempdirManager,
@@ -35,6 +35,7 @@
         self.assertEqual(cmd.optimize, 2)
 
     @unittest.skipIf(sys.dont_write_bytecode, 'byte-compile disabled')
+    @unittest.skipUnless(has_subprocess_support, "distutils cannot spawn child processes")
     def test_byte_compile(self):
         project_dir, dist = self.create_dist()
         os.chdir(project_dir)
diff --git a/Lib/distutils/tests/test_spawn.py b/Lib/distutils/tests/test_spawn.py
index 4ec767b120..10003aa99e 100644
--- a/Lib/distutils/tests/test_spawn.py
+++ b/Lib/distutils/tests/test_spawn.py
@@ -3,7 +3,7 @@
 import stat
 import sys
 import unittest.mock
-from test.support import run_unittest, unix_shell
+from test.support import run_unittest, unix_shell, has_subprocess_support
 from test.support import os_helper
 
 from distutils.spawn import find_executable
@@ -15,8 +15,7 @@
                     support.LoggingSilencer,
                     unittest.TestCase):
 
-    @unittest.skipUnless(os.name in ('nt', 'posix'),
-                         'Runs only under posix or nt')
+    @unittest.skipUnless(has_subprocess_support, "distutils cannot spawn child processes")
     def test_spawn(self):
         tmpdir = self.mkdtemp()
 
diff --git a/Lib/distutils/tests/test_sysconfig.py b/Lib/distutils/tests/test_sysconfig.py
index 59676b0e0b..6bbeea0df7 100644
--- a/Lib/distutils/tests/test_sysconfig.py
+++ b/Lib/distutils/tests/test_sysconfig.py
@@ -10,7 +10,7 @@
 from distutils import sysconfig
 from distutils.ccompiler import get_default_compiler
 from distutils.tests import support
-from test.support import run_unittest, swap_item
+from test.support import run_unittest, swap_item, has_subprocess_support
 from test.support.os_helper import TESTFN
 from test.support.warnings_helper import check_warnings
 
@@ -247,6 +247,7 @@
         self.assertIsNotNone(vars['SO'])
         self.assertEqual(vars['SO'], vars['EXT_SUFFIX'])
 
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def test_customize_compiler_before_get_config_vars(self):
         # Issue #21923: test that a Distribution compiler
         # instance can be called without an explicit call to
diff --git a/Lib/distutils/tests/test_util.py b/Lib/distutils/tests/test_util.py
index d4a01c6e91..f3fc4607e1 100644
--- a/Lib/distutils/tests/test_util.py
+++ b/Lib/distutils/tests/test_util.py
@@ -3,7 +3,7 @@
 import sys
 import unittest
 from copy import copy
-from test.support import run_unittest
+from test.support import run_unittest, has_subprocess_support
 from unittest import mock
 
 from distutils.errors import DistutilsPlatformError, DistutilsByteCompileError
@@ -234,6 +234,7 @@
 
         # XXX platforms to be covered: mac
 
+    @unittest.skipUnless(has_subprocess_support, "distutils cannot spawn child processes")
     def test_check_environ(self):
         util._environ_checked = 0
         os.environ.pop('HOME', None)
diff --git a/Lib/distutils/unixccompiler.py b/Lib/distutils/unixccompiler.py
index d00c48981e..5d12b4779d 100644
--- a/Lib/distutils/unixccompiler.py
+++ b/Lib/distutils/unixccompiler.py
@@ -270,9 +270,9 @@
         static_f = self.library_filename(lib, lib_type='static')
 
         if sys.platform == 'darwin':
-            # On OSX users can specify an alternate SDK using
-            # '-isysroot', calculate the SDK root if it is specified
-            # (and use it further on)
+            # On macOS users can specify an alternate SDK using
+            # '-isysroot <path>' or --sysroot=<path>, calculate the SDK root
+            # if it is specified (and use it further on)
             #
             # Note that, as of Xcode 7, Apple SDKs may contain textual stub
             # libraries with .tbd extensions rather than the normal .dylib
@@ -291,12 +291,14 @@
             cflags = sysconfig.get_config_var('CFLAGS')
             m = re.search(r'-isysroot\s*(\S+)', cflags)
             if m is None:
-                sysroot = _osx_support._default_sysroot(sysconfig.get_config_var('CC'))
+                m = re.search(r'--sysroot=(\S+)', cflags)
+                if m is None:
+                    sysroot = _osx_support._default_sysroot(sysconfig.get_config_var('CC'))
+                else:
+                    sysroot = m.group(1)
             else:
                 sysroot = m.group(1)
 
-
-
         for dir in dirs:
             shared = os.path.join(dir, shared_f)
             dylib = os.path.join(dir, dylib_f)
diff --git a/Lib/importlib/_bootstrap_external.py b/Lib/importlib/_bootstrap_external.py
index 49bcaea78d..891356e54d 100644
--- a/Lib/importlib/_bootstrap_external.py
+++ b/Lib/importlib/_bootstrap_external.py
@@ -52,7 +52,7 @@
 
 # Bootstrap-related code ######################################################
 _CASE_INSENSITIVE_PLATFORMS_STR_KEY = 'win',
-_CASE_INSENSITIVE_PLATFORMS_BYTES_KEY = 'cygwin', 'darwin'
+_CASE_INSENSITIVE_PLATFORMS_BYTES_KEY = 'cygwin', 'darwin', 'ios', 'tvos', 'watchos'
 _CASE_INSENSITIVE_PLATFORMS =  (_CASE_INSENSITIVE_PLATFORMS_BYTES_KEY
                                 + _CASE_INSENSITIVE_PLATFORMS_STR_KEY)
 
diff --git a/Lib/platform.py b/Lib/platform.py
index e32f9c11cd..be08f544e7 100755
--- a/Lib/platform.py
+++ b/Lib/platform.py
@@ -449,6 +449,34 @@
     # If that also doesn't work return the default values
     return release, versioninfo, machine
 
+
+def iOS_ver():
+    """ Get iOS/tvOS version information, and return it as a
+        tuple (system, release, model). All tuple entries are strings.
+        Equivalent of:
+        system = [[UIDevice currentDevice].systemName] UTF8String]
+        release = [[UIDevice currentDevice].systemVersion] UTF8String]
+        model = [[UIDevice currentDevice].model] UTF8String]
+    """
+    import _ios_support
+    return _ios_support.get_platform_ios()
+
+def is_simulator():
+    """Determine if the current platform is a device simulator.
+    Only useful when working with iOS, tvOS or watchOS, because
+    Apple provides simulator platforms for those devices.
+    If the platform is actual hardware, returns False. Will also
+    return False for device *emulators*, which are indistinguishable
+    from actual devices because they are reproducing actual device
+    properties.
+    """
+    if sys.platform in ('ios', 'tvos', 'watchos'):
+        return sys.implementation._multiarch.endswith('simulator')
+
+    # All other platforms aren't simulators.
+    return False
+
+
 def _java_getprop(name, default):
 
     from java.lang import System
@@ -605,7 +633,7 @@
         default in case the command should fail.
 
     """
-    if sys.platform in ('dos', 'win32', 'win16'):
+    if sys.platform in ('dos', 'win32', 'win16', 'ios', 'tvos', 'watchos'):
         # XXX Others too ?
         return default
 
@@ -744,6 +772,24 @@
             csid, cpu_number = vms_lib.getsyi('SYI$_CPU', 0)
             return 'Alpha' if cpu_number >= 128 else 'VAX'
 
+    # On iOS, tvOS and watchOS, os.uname returns the architecture
+    # as uname.machine. On device it doesn't; but there's only
+    # on CPU architecture on device
+    def get_ios():
+        if sys.implementation._multiarch.endswith('simulator'):
+            return os.uname().machine
+        return 'arm64'
+
+    def get_tvos():
+        if sys.implementation._multiarch.endswith('simulator'):
+            return os.uname().machine
+        return 'arm64'
+
+    def get_watchos():
+        if sys.implementation._multiarch.endswith('simulator'):
+            return os.uname().machine
+        return 'arm64_32'
+
     def from_subprocess():
         """
         Fall back to `uname -p`
@@ -891,6 +937,14 @@
         system = 'Windows'
         release = 'Vista'
 
+    # Normalize responses on Apple mobile platforms
+    if sys.platform in ('ios', 'tvos'):
+        system, release, model = iOS_ver()
+        # Simulator devices report as "arm64" or "x86_64";
+        # use the model as the basis for the normalized machine name.
+        if sys.implementation._multiarch.endswith('simulator'):
+            machine = f'{model} Simulator'
+
     vals = system, node, release, version, machine
     # Replace 'unknown' values with the more portable ''
     _uname_cache = uname_result(*map(_unknown_as_blank, vals))
@@ -1203,11 +1257,13 @@
         system, release, version = system_alias(system, release, version)
 
     if system == 'Darwin':
-        # macOS (darwin kernel)
-        macos_release = mac_ver()[0]
-        if macos_release:
-            system = 'macOS'
-            release = macos_release
+        if sys.platform in ('ios', 'tvos'):
+            system, release, model = iOS_ver()
+        else:
+            macos_release = mac_ver()[0]
+            if macos_release:
+                system = 'macOS'
+                release = macos_release
 
     if system == 'Windows':
         # MS platforms
diff --git a/Lib/site.py b/Lib/site.py
index 939893eb5e..8c550ed95a 100644
--- a/Lib/site.py
+++ b/Lib/site.py
@@ -294,6 +294,9 @@
 
     if sys.platform == 'darwin' and sys._framework:
         return f'{userbase}/lib/python/site-packages'
+    elif sys.platform in ('ios', 'tvos', 'watchos'):
+        from sysconfig import get_path
+        return get_path('purelib', sys.platform)
 
     return f'{userbase}/lib/python{version[0]}.{version[1]}/site-packages'
 
diff --git a/Lib/subprocess.py b/Lib/subprocess.py
index a414321b9d..f2846db171 100644
--- a/Lib/subprocess.py
+++ b/Lib/subprocess.py
@@ -96,6 +96,8 @@
                     "CREATE_NO_WINDOW", "DETACHED_PROCESS",
                     "CREATE_DEFAULT_ERROR_MODE", "CREATE_BREAKAWAY_FROM_JOB"])
 
+# Some platforms do not support processes
+_can_fork_exec = sys.platform not in {"ios", "tvos", "watchos"}
 
 # Exception classes used by this module.
 class SubprocessError(Exception): pass
@@ -762,6 +764,9 @@
                  pass_fds=(), *, user=None, group=None, extra_groups=None,
                  encoding=None, errors=None, text=None, umask=-1, pipesize=-1):
         """Create new Popen instance."""
+        if not _can_fork_exec:
+            raise RuntimeError(f"Subprocesses are not supported on {sys.platform}")
+
         _cleanup()
         # Held while anything is calling waitpid before returncode has been
         # updated to prevent clobbering returncode if wait() or poll() are
@@ -1858,7 +1863,7 @@
             else:
                 self.returncode = waitstatus_to_exitcode(sts)
 
-        def _internal_poll(self, _deadstate=None, _waitpid=os.waitpid,
+        def _internal_poll(self, _deadstate=None, _waitpid=None,
                 _WNOHANG=os.WNOHANG, _ECHILD=errno.ECHILD):
             """Check if child process has terminated.  Returns returncode
             attribute.
@@ -1867,6 +1872,8 @@
             outside of the local scope (nor can any methods it calls).
 
             """
+            if _waitpid is None:
+                _waitpid = os.waitpid
             if self.returncode is None:
                 if not self._waitpid_lock.acquire(False):
                     # Something else is busy calling waitpid.  Don't allow two
diff --git a/Lib/sysconfig.py b/Lib/sysconfig.py
index daf9f00006..82d5af767c 100644
--- a/Lib/sysconfig.py
+++ b/Lib/sysconfig.py
@@ -56,6 +56,33 @@
         'scripts': '{base}/Scripts',
         'data': '{base}',
         },
+    'ios': {
+        'stdlib': '{installed_base}/lib/python%s' % sys.version[:3],
+        'platstdlib': '{installed_base}/lib/python%s' % sys.version[:3],
+        'purelib': '{installed_base}/lib/python%s/site-packages' % sys.version[:3],
+        'platlib': '{installed_base}/lib/python%s/site-packages' % sys.version[:3],
+        'include': '{installed_base}/include',
+        'scripts': '{installed_base}/bin',
+        'data': '{installed_base}/Resources',
+        },
+    'tvos': {
+        'stdlib': '{installed_base}/lib/python%s' % sys.version[:3],
+        'platstdlib': '{installed_base}/lib/python%s' % sys.version[:3],
+        'purelib': '{installed_base}/lib/python%s/site-packages' % sys.version[:3],
+        'platlib': '{installed_base}/lib/python%s/site-packages' % sys.version[:3],
+        'include': '{installed_base}/include',
+        'scripts': '{installed_base}/bin',
+        'data': '{installed_base}/Resources',
+        },
+    'watchos': {
+        'stdlib': '{installed_base}/lib/python%s' % sys.version[:3],
+        'platstdlib': '{installed_base}/lib/python%s' % sys.version[:3],
+        'purelib': '{installed_base}/lib/python%s/site-packages' % sys.version[:3],
+        'platlib': '{installed_base}/lib/python%s/site-packages' % sys.version[:3],
+        'include': '{installed_base}/include',
+        'scripts': '{installed_base}/bin',
+        'data': '{installed_base}/Resources',
+        },
     }
 
 
@@ -231,12 +258,19 @@
             'home': 'posix_home',
             'user': 'nt_user',
         }
+    if sys.platform in ('ios', 'tvos', 'watchos'):
+        return {
+            'prefix': sys.platform,
+            'home': sys.platform,
+            'user': sys.platform,
+        }
     if sys.platform == 'darwin' and sys._framework:
         return {
             'prefix': 'posix_prefix',
             'home': 'posix_home',
             'user': 'osx_framework_user',
         }
+
     return {
         'prefix': 'posix_prefix',
         'home': 'posix_home',
@@ -740,10 +774,16 @@
         if m:
             release = m.group()
     elif osname[:6] == "darwin":
-        import _osx_support
-        osname, release, machine = _osx_support.get_platform_osx(
-                                            get_config_vars(),
-                                            osname, release, machine)
+        if sys.platform in ("ios", "tvos", "watchos"):
+            import _ios_support
+            _, release, model = _ios_support.get_platform_ios()
+            osname = sys.platform
+            machine = sys.implementation._multiarch
+        else:
+            import _osx_support
+            osname, release, machine = _osx_support.get_platform_osx(
+                                                get_config_vars(),
+                                                osname, release, machine)
 
     return f"{osname}-{release}-{machine}"
 
diff --git a/Lib/test/support/__init__.py b/Lib/test/support/__init__.py
index c9a80c2a62..4bcfe50b5c 100644
--- a/Lib/test/support/__init__.py
+++ b/Lib/test/support/__init__.py
@@ -43,7 +43,7 @@
     "check__all__", "skip_if_buggy_ucrt_strfptime",
     "check_disallow_instantiation", "check_sanitizer", "skip_if_sanitizer",
     # sys
-    "is_jython", "is_android", "check_impl_detail", "unix_shell",
+    "is_jython", "is_android", "is_apple_mobile", "check_impl_detail", "unix_shell",
     "setswitchinterval",
     # network
     "open_urlresource",
@@ -469,11 +469,24 @@
 
 is_android = hasattr(sys, 'getandroidapilevel')
 
-if sys.platform not in ('win32', 'vxworks'):
+if sys.platform not in ('win32', 'vxworks', 'ios', 'tvos', 'watchos'):
     unix_shell = '/system/bin/sh' if is_android else '/bin/sh'
 else:
     unix_shell = None
 
+# Apple mobile platforms (iOS/tvOS/watchOS) are POSIX-like but do not
+# have subprocess or fork support.
+is_apple_mobile = sys.platform in ('ios', 'tvos', 'watchos')
+
+has_fork_support = (
+    hasattr(os, "fork")
+    and not is_apple_mobile
+)
+
+has_subprocess_support = (
+    not is_apple_mobile
+)
+
 # Define the URL of a dedicated HTTP server for the network tests.
 # The URL must use clear-text HTTP: no redirection to encrypted HTTPS.
 TEST_HTTP_URL = "http://www.pythontest.net"
diff --git a/Lib/test/support/script_helper.py b/Lib/test/support/script_helper.py
index 6d699c8486..8e7341bd21 100644
--- a/Lib/test/support/script_helper.py
+++ b/Lib/test/support/script_helper.py
@@ -8,10 +8,12 @@
 import os.path
 import subprocess
 import py_compile
+import unittest
 import zipfile
 
 from importlib.util import source_from_cache
 from test import support
+from test.support import has_subprocess_support
 from test.support.import_helper import make_legacy_pyc
 
 
@@ -19,6 +21,7 @@
 __cached_interp_requires_environment = None
 
 
+@unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
 def interpreter_requires_environment():
     """
     Returns True if our sys.executable interpreter requires environment
@@ -139,6 +142,7 @@
     return _PythonRunResult(rc, out, err), cmd_line
 
 
+@unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
 def _assert_python(expected_success, /, *args, **env_vars):
     res, cmd_line = run_python_until_end(*args, **env_vars)
     if (res.rc and expected_success) or (not res.rc and not expected_success):
@@ -171,6 +175,7 @@
     return _assert_python(False, *args, **env_vars)
 
 
+@unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
 def spawn_python(*args, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, **kw):
     """Run a Python subprocess with the given arguments.
 
diff --git a/Lib/test/test_asyncio/test_events.py b/Lib/test/test_asyncio/test_events.py
index bed7b5d30b..d17fc9c9ff 100644
--- a/Lib/test/test_asyncio/test_events.py
+++ b/Lib/test/test_asyncio/test_events.py
@@ -32,6 +32,7 @@
 from asyncio import selector_events
 from test.test_asyncio import utils as test_utils
 from test import support
+from test.support import is_apple_mobile, has_subprocess_support
 from test.support import socket_helper
 from test.support import threading_helper
 from test.support import ALWAYS_EQ, LARGEST, SMALLEST
@@ -541,6 +542,7 @@
             self._basetest_create_connection(conn_fut)
 
     @socket_helper.skip_unless_bind_unix_socket
+    @unittest.skipIf(is_apple_mobile, "%s doesn't fully support UNIX sockets." % sys.platform)
     def test_create_unix_connection(self):
         # Issue #20682: On Mac OS X Tiger, getsockname() returns a
         # zero-length address for UNIX socket.
@@ -633,6 +635,7 @@
         self.assertEqual(cm.exception.reason, 'CERTIFICATE_VERIFY_FAILED')
 
     @unittest.skipIf(ssl is None, 'No ssl module')
+    @unittest.skipIf(is_apple_mobile, "%s doesn't fully support UNIX sockets." % sys.platform)
     def test_create_ssl_connection(self):
         with test_utils.run_test_server(use_ssl=True) as httpd:
             create_connection = functools.partial(
@@ -644,6 +647,7 @@
 
     @socket_helper.skip_unless_bind_unix_socket
     @unittest.skipIf(ssl is None, 'No ssl module')
+    @unittest.skipIf(is_apple_mobile, "%s doesn't fully support UNIX sockets." % sys.platform)
     def test_create_ssl_unix_connection(self):
         # Issue #20682: On Mac OS X Tiger, getsockname() returns a
         # zero-length address for UNIX socket.
@@ -867,6 +871,7 @@
         return server, path
 
     @socket_helper.skip_unless_bind_unix_socket
+    @unittest.skipIf(is_apple_mobile, "%s doesn't fully support UNIX sockets." % sys.platform)
     def test_create_unix_server(self):
         proto = MyProto(loop=self.loop)
         server, path = self._make_unix_server(lambda: proto)
@@ -895,6 +900,7 @@
         server.close()
 
     @unittest.skipUnless(hasattr(socket, 'AF_UNIX'), 'No UNIX Sockets')
+    @unittest.skipIf(is_apple_mobile, "%s doesn't fully support UNIX sockets." % sys.platform)
     def test_create_unix_server_path_socket_error(self):
         proto = MyProto(loop=self.loop)
         sock = socket.socket()
@@ -960,6 +966,7 @@
 
     @socket_helper.skip_unless_bind_unix_socket
     @unittest.skipIf(ssl is None, 'No ssl module')
+    @unittest.skipIf(is_apple_mobile, "%s doesn't fully support UNIX sockets." % sys.platform)
     def test_create_unix_server_ssl(self):
         proto = MyProto(loop=self.loop)
         server, path = self._make_ssl_unix_server(
@@ -990,6 +997,7 @@
         server.close()
 
     @unittest.skipIf(ssl is None, 'No ssl module')
+    @unittest.skipIf(is_apple_mobile, "%s doesn't fully support UNIX sockets." % sys.platform)
     def test_create_server_ssl_verify_failed(self):
         proto = MyProto(loop=self.loop)
         server, host, port = self._make_ssl_server(
@@ -1020,6 +1028,7 @@
 
     @socket_helper.skip_unless_bind_unix_socket
     @unittest.skipIf(ssl is None, 'No ssl module')
+    @unittest.skipIf(is_apple_mobile, "%s doesn't fully support UNIX sockets." % sys.platform)
     def test_create_unix_server_ssl_verify_failed(self):
         proto = MyProto(loop=self.loop)
         server, path = self._make_ssl_unix_server(
@@ -1080,6 +1089,7 @@
 
     @socket_helper.skip_unless_bind_unix_socket
     @unittest.skipIf(ssl is None, 'No ssl module')
+    @unittest.skipIf(is_apple_mobile, "%s doesn't fully support UNIX sockets." % sys.platform)
     def test_create_unix_server_ssl_verified(self):
         proto = MyProto(loop=self.loop)
         server, path = self._make_ssl_unix_server(
@@ -1742,6 +1752,7 @@
             next(it)
 
 
+@unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
 class SubprocessTestsMixin:
 
     def check_terminated(self, returncode):
diff --git a/Lib/test/test_asyncio/test_streams.py b/Lib/test/test_asyncio/test_streams.py
index 227b2279e1..54143e8dfc 100644
--- a/Lib/test/test_asyncio/test_streams.py
+++ b/Lib/test/test_asyncio/test_streams.py
@@ -17,6 +17,7 @@
 
 import asyncio
 from test.test_asyncio import utils as test_utils
+from test.support import is_apple_mobile, has_subprocess_support
 
 
 def tearDownModule():
@@ -60,6 +61,7 @@
             self._basetest_open_connection(conn_fut)
 
     @socket_helper.skip_unless_bind_unix_socket
+    @unittest.skipIf(is_apple_mobile, "%s doesn't fully support UNIX sockets." % sys.platform)
     def test_open_unix_connection(self):
         with test_utils.run_test_unix_server() as httpd:
             conn_fut = asyncio.open_unix_connection(httpd.address)
@@ -91,6 +93,7 @@
 
     @socket_helper.skip_unless_bind_unix_socket
     @unittest.skipIf(ssl is None, 'No ssl module')
+    @unittest.skipIf(is_apple_mobile, "%s doesn't fully support UNIX sockets." % sys.platform)
     def test_open_unix_connection_no_loop_ssl(self):
         with test_utils.run_test_unix_server(use_ssl=True) as httpd:
             conn_fut = asyncio.open_unix_connection(
@@ -119,6 +122,7 @@
             self._basetest_open_connection_error(conn_fut)
 
     @socket_helper.skip_unless_bind_unix_socket
+    @unittest.skipIf(is_apple_mobile, "%s doesn't fully support UNIX sockets." % sys.platform)
     def test_open_unix_connection_error(self):
         with test_utils.run_test_unix_server() as httpd:
             conn_fut = asyncio.open_unix_connection(httpd.address)
@@ -637,6 +641,7 @@
         self.assertEqual(messages, [])
 
     @socket_helper.skip_unless_bind_unix_socket
+    @unittest.skipIf(is_apple_mobile, "%s doesn't fully support UNIX sockets." % sys.platform)
     def test_start_unix_server(self):
 
         class MyServer:
@@ -707,6 +712,7 @@
         self.assertEqual(messages, [])
 
     @unittest.skipIf(sys.platform == 'win32', "Don't have pipes")
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def test_read_all_from_pipe_reader(self):
         # See asyncio issue 168.  This test is derived from the example
         # subprocess_attach_read_pipe.py, but we configure the
diff --git a/Lib/test/test_asyncio/test_subprocess.py b/Lib/test/test_asyncio/test_subprocess.py
index 14fa6dd76f..a9a9561509 100644
--- a/Lib/test/test_asyncio/test_subprocess.py
+++ b/Lib/test/test_asyncio/test_subprocess.py
@@ -10,7 +10,7 @@
 from asyncio import subprocess
 from test.test_asyncio import utils as test_utils
 from test import support
-from test.support import os_helper
+from test.support import os_helper, has_subprocess_support
 
 if sys.platform != 'win32':
     from asyncio import unix_events
@@ -104,6 +104,7 @@
         transport.close()
 
 
+@unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
 class SubprocessMixin:
 
     def test_stdin_stdout(self):
diff --git a/Lib/test/test_asyncio/test_unix_events.py b/Lib/test/test_asyncio/test_unix_events.py
index 1d922783ce..d40943c4c3 100644
--- a/Lib/test/test_asyncio/test_unix_events.py
+++ b/Lib/test/test_asyncio/test_unix_events.py
@@ -13,6 +13,7 @@
 import threading
 import unittest
 from unittest import mock
+from test.support import is_apple_mobile, has_subprocess_support
 from test.support import os_helper
 from test.support import socket_helper
 
@@ -276,6 +277,7 @@
 
 @unittest.skipUnless(hasattr(socket, 'AF_UNIX'),
                      'UNIX Sockets are not supported')
+@unittest.skipIf(is_apple_mobile, "%s doesn't fully support UNIX sockets." % sys.platform)
 class SelectorEventLoopUnixSocketTests(test_utils.TestCase):
 
     def setUp(self):
@@ -1134,6 +1136,7 @@
             NotImplementedError, watcher._do_waitpid, f)
 
 
+@unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
 class ChildWatcherTestsMixin:
 
     ignore_warnings = mock.patch.object(log.logger, "warning")
diff --git a/Lib/test/test_base64.py b/Lib/test/test_base64.py
index 418492432a..88a302f13f 100644
--- a/Lib/test/test_base64.py
+++ b/Lib/test/test_base64.py
@@ -3,6 +3,7 @@
 import binascii
 import os
 from array import array
+from test.support import has_subprocess_support
 from test.support import os_helper
 from test.support import script_helper
 
@@ -754,6 +755,7 @@
         self.assertEqual(b16encode(b"foobar"), b"666F6F626172")
 
 
+@unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
 class TestMain(unittest.TestCase):
     def tearDown(self):
         if os.path.exists(os_helper.TESTFN):
diff --git a/Lib/test/test_capi.py b/Lib/test/test_capi.py
index 0adb689beb..3b8f2b8b65 100644
--- a/Lib/test/test_capi.py
+++ b/Lib/test/test_capi.py
@@ -17,6 +17,7 @@
 import weakref
 from test import support
 from test.support import MISSING_C_DOCSTRINGS
+from test.support import has_subprocess_support
 from test.support import import_helper
 from test.support import threading_helper
 from test.support import warnings_helper
@@ -61,6 +62,7 @@
         self.assertEqual(testfunction.attribute, "test")
         self.assertRaises(AttributeError, setattr, inst.testfunction, "attribute", "test")
 
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def test_no_FatalError_infinite_loop(self):
         with support.SuppressCrashReport():
             p = subprocess.Popen([sys.executable, "-c",
@@ -802,6 +804,7 @@
         self.assertEqual(main_attr_id, subinterp_attr_id)
 
 
+@unittest.skipUnless(threading, 'Threading required for this test.')
 class TestThreadState(unittest.TestCase):
 
     @threading_helper.reap_threads
diff --git a/Lib/test/test_cmd_line.py b/Lib/test/test_cmd_line.py
index 84bd883609..ab13da4fa5 100644
--- a/Lib/test/test_cmd_line.py
+++ b/Lib/test/test_cmd_line.py
@@ -9,7 +9,7 @@
 import textwrap
 import unittest
 from test import support
-from test.support import os_helper
+from test.support import os_helper, has_subprocess_support
 from test.support.script_helper import (
     spawn_python, kill_python, assert_python_ok, assert_python_failure,
     interpreter_requires_environment
@@ -68,6 +68,7 @@
         rc, out, err = assert_python_ok('-vv')
         self.assertNotIn(b'stack overflow', err)
 
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     @unittest.skipIf(interpreter_requires_environment(),
                      'Cannot run -E tests when PYTHON env vars are required.')
     def test_xoptions(self):
@@ -86,6 +87,7 @@
         opts = get_xoptions('-Xa', '-Xb=c,d=e')
         self.assertEqual(opts, {'a': True, 'b': 'c,d=e'})
 
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def test_showrefcount(self):
         def run_python(*args):
             # this is similar to assert_python_ok but doesn't strip
@@ -178,6 +180,7 @@
     # arguments as unicode (using wmain() instead of main()).
     @unittest.skipIf(sys.platform == 'win32',
                      'Windows has a native unicode API')
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def test_undecodable_code(self):
         undecodable = b"\xff"
         env = os.environ.copy()
@@ -293,6 +296,7 @@
                          'False False False\n'
                          'False False True\n')
 
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def test_unbuffered_output(self):
         # Test expected operation of the '-u' switch
         for stream in ('stdout', 'stderr'):
@@ -351,6 +355,7 @@
         # for empty and unset PYTHONPATH
         self.assertEqual(out1, out2)
 
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def test_displayhook_unencodable(self):
         for encoding in ('ascii', 'latin-1', 'utf-8'):
             env = os.environ.copy()
@@ -369,6 +374,7 @@
             escaped = repr(text).encode(encoding, 'backslashreplace')
             self.assertIn(escaped, data)
 
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def check_input(self, code, expected):
         with tempfile.NamedTemporaryFile("wb+") as stdin:
             sep = os.linesep.encode('ASCII')
@@ -444,6 +450,7 @@
     @unittest.skipIf(os.name != 'posix', "test needs POSIX semantics")
     @unittest.skipIf(sys.platform == "vxworks",
                          "test needs preexec support in subprocess.Popen")
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def _test_no_stdio(self, streams):
         code = """if 1:
             import os, sys
diff --git a/Lib/test/test_concurrent_futures.py b/Lib/test/test_concurrent_futures.py
index e174d5464d..56a6a6f5a4 100644
--- a/Lib/test/test_concurrent_futures.py
+++ b/Lib/test/test_concurrent_futures.py
@@ -5,7 +5,7 @@
 # Skip tests if _multiprocessing wasn't built.
 import_helper.import_module('_multiprocessing')
 
-from test.support import hashlib_helper
+from test.support import hashlib_helper, has_subprocess_support
 from test.support.script_helper import assert_python_ok
 
 import contextlib
@@ -151,6 +151,7 @@
     executor_type = futures.ThreadPoolExecutor
 
 
+@unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
 class ProcessPoolForkMixin(ExecutorMixin):
     executor_type = futures.ProcessPoolExecutor
     ctx = "fork"
@@ -165,6 +166,7 @@
         return super().get_context()
 
 
+@unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
 class ProcessPoolSpawnMixin(ExecutorMixin):
     executor_type = futures.ProcessPoolExecutor
     ctx = "spawn"
@@ -177,6 +179,7 @@
         return super().get_context()
 
 
+@unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
 class ProcessPoolForkserverMixin(ExecutorMixin):
     executor_type = futures.ProcessPoolExecutor
     ctx = "forkserver"
diff --git a/Lib/test/test_doctest.py b/Lib/test/test_doctest.py
index ebd4ad9192..bc2809f199 100644
--- a/Lib/test/test_doctest.py
+++ b/Lib/test/test_doctest.py
@@ -4,6 +4,7 @@
 
 from test import support
 from test.support import import_helper
+from test.support import is_apple_mobile
 from test.support import os_helper
 import doctest
 import functools
@@ -2875,7 +2876,12 @@
     TestResults(failed=1, attempted=1)
     """
 
-def test_CLI(): r"""
+if is_apple_mobile:
+    # Mobile platforms can't invoke doctest from the command line,
+    # so skip this test.
+    pass
+else:
+    def test_CLI(): r"""
 The doctest module can be used to run doctests against an arbitrary file.
 These tests test this CLI functionality.
 
diff --git a/Lib/test/test_eintr.py b/Lib/test/test_eintr.py
index 528147802b..f8f0d9c3c7 100644
--- a/Lib/test/test_eintr.py
+++ b/Lib/test/test_eintr.py
@@ -2,10 +2,11 @@
 import signal
 import unittest
 from test import support
-from test.support import script_helper
+from test.support import script_helper, has_subprocess_support
 
 
 @unittest.skipUnless(os.name == "posix", "only supported on Unix")
+@unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
 class EINTRTests(unittest.TestCase):
 
     @unittest.skipUnless(hasattr(signal, "setitimer"), "requires setitimer()")
diff --git a/Lib/test/test_faulthandler.py b/Lib/test/test_faulthandler.py
index e0f09e821d..ae84d480ba 100644
--- a/Lib/test/test_faulthandler.py
+++ b/Lib/test/test_faulthandler.py
@@ -7,6 +7,7 @@
 import subprocess
 import sys
 from test import support
+from test.support import has_subprocess_support
 from test.support import os_helper
 from test.support import script_helper, is_android
 from test.support import skip_if_sanitizer
@@ -401,6 +402,7 @@
         finally:
             sys.stderr = orig_stderr
 
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def test_disabled_by_default(self):
         # By default, the module should be disabled
         code = "import faulthandler; print(faulthandler.is_enabled())"
@@ -409,6 +411,7 @@
         output = subprocess.check_output(args)
         self.assertEqual(output.rstrip(), b"False")
 
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def test_sys_xoptions(self):
         # Test python -X faulthandler
         code = "import faulthandler; print(faulthandler.is_enabled())"
@@ -421,6 +424,7 @@
         output = subprocess.check_output(args, env=env)
         self.assertEqual(output.rstrip(), b"True")
 
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def test_env_var(self):
         # empty env var
         code = "import faulthandler; print(faulthandler.is_enabled())"
diff --git a/Lib/test/test_fcntl.py b/Lib/test/test_fcntl.py
index fc8c39365f..16235b8397 100644
--- a/Lib/test/test_fcntl.py
+++ b/Lib/test/test_fcntl.py
@@ -6,7 +6,7 @@
 import sys
 import unittest
 from multiprocessing import Process
-from test.support import verbose, cpython_only
+from test.support import verbose, cpython_only, is_apple_mobile
 from test.support.import_helper import import_module
 from test.support.os_helper import TESTFN, unlink
 
@@ -25,7 +25,7 @@
         start_len = "qq"
 
     if (sys.platform.startswith(('netbsd', 'freebsd', 'openbsd'))
-        or sys.platform == 'darwin'):
+        or sys.platform == 'darwin' or is_apple_mobile):
         if struct.calcsize('l') == 8:
             off_t = 'l'
             pid_t = 'i'
diff --git a/Lib/test/test_file_eintr.py b/Lib/test/test_file_eintr.py
index 01408d838a..faf039fc69 100644
--- a/Lib/test/test_file_eintr.py
+++ b/Lib/test/test_file_eintr.py
@@ -15,6 +15,7 @@
 import sys
 import time
 import unittest
+from test.support import has_subprocess_support
 
 # Test import all of the things we're about to try testing up front.
 import _io
@@ -69,6 +70,7 @@
         self.fail('Error from IO process %s:\nSTDOUT:\n%sSTDERR:\n%s\n' %
                   (why, stdout.decode(), stderr.decode()))
 
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def _test_reading(self, data_to_write, read_and_verify_code):
         """Generic buffered read method test harness to validate EINTR behavior.
 
diff --git a/Lib/test/test_gc.py b/Lib/test/test_gc.py
index 6c28b2b677..503495e653 100644
--- a/Lib/test/test_gc.py
+++ b/Lib/test/test_gc.py
@@ -1,7 +1,7 @@
 import unittest
 import unittest.mock
 from test.support import (verbose, refcount_test,
-                          cpython_only)
+                          cpython_only, has_subprocess_support)
 from test.support.import_helper import import_module
 from test.support.os_helper import temp_dir, TESTFN, unlink
 from test.support.script_helper import assert_python_ok, make_script
@@ -681,6 +681,8 @@
             del x
             gc.set_debug(%s)
         """
+
+        @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
         def run_command(code):
             p = subprocess.Popen([sys.executable, "-Wd", "-c", code],
                 stdout=subprocess.PIPE,
diff --git a/Lib/test/test_gdb.py b/Lib/test/test_gdb.py
index 5f554897f8..18955cb173 100644
--- a/Lib/test/test_gdb.py
+++ b/Lib/test/test_gdb.py
@@ -33,6 +33,8 @@
         # This is what "no gdb" looks like.  There may, however, be other
         # errors that manifest this way too.
         raise unittest.SkipTest("Couldn't find gdb on the path")
+    except RuntimeError:
+        raise unittest.SkipTest('Test requires support for subprocesses.')
 
     # Regex to parse:
     # 'GNU gdb (GDB; SUSE Linux Enterprise 12) 7.7\n' -> 7.7
diff --git a/Lib/test/test_httpservers.py b/Lib/test/test_httpservers.py
index 8fdbab4ec0..4ac1ef2158 100644
--- a/Lib/test/test_httpservers.py
+++ b/Lib/test/test_httpservers.py
@@ -30,6 +30,8 @@
 
 import unittest
 from test import support
+from test.support import is_apple_mobile
+from test.support import has_subprocess_support
 from test.support import os_helper
 from test.support import threading_helper
 
@@ -400,7 +402,7 @@
         with open(os.path.join(self.tempdir, filename), 'wb') as f:
             f.write(os_helper.TESTFN_UNDECODABLE)
         response = self.request(self.base_url + '/')
-        if sys.platform == 'darwin':
+        if sys.platform == 'darwin' or is_apple_mobile:
             # On Mac OS the HFS+ filesystem replaces bytes that aren't valid
             # UTF-8 into a percent-encoded value.
             for name in os.listdir(self.tempdir):
@@ -659,6 +661,7 @@
 
 @unittest.skipIf(hasattr(os, 'geteuid') and os.geteuid() == 0,
         "This test can't be run reliably as root (issue #13308).")
+@unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
 class CGIHTTPServerTestCase(BaseTestCase):
     class request_handler(NoLogRequestHandler, CGIHTTPRequestHandler):
         pass
diff --git a/Lib/test/test_io.py b/Lib/test/test_io.py
index fb83762cb6..cd231e461c 100644
--- a/Lib/test/test_io.py
+++ b/Lib/test/test_io.py
@@ -40,6 +40,7 @@
 from test.support.script_helper import (
     assert_python_ok, assert_python_failure, run_python_until_end)
 from test.support import import_helper
+from test.support import is_apple_mobile
 from test.support import os_helper
 from test.support import threading_helper
 from test.support import warnings_helper
@@ -601,7 +602,7 @@
         # On Windows and Mac OSX this test consumes large resources; It takes
         # a long time to build the >2 GiB file and takes >2 GiB of disk space
         # therefore the resource must be enabled to run this test.
-        if sys.platform[:3] == 'win' or sys.platform == 'darwin':
+        if sys.platform[:3] == 'win' or sys.platform == 'darwin' or is_apple_mobile:
             support.requires(
                 'largefile',
                 'test requires %s bytes and a long time to run' % self.LARGE)
diff --git a/Lib/test/test_json/test_tool.py b/Lib/test/test_json/test_tool.py
index 1d7fca6efb..0e0235f44f 100644
--- a/Lib/test/test_json/test_tool.py
+++ b/Lib/test/test_json/test_tool.py
@@ -6,7 +6,7 @@
 import subprocess
 
 from test import support
-from test.support import os_helper
+from test.support import os_helper, has_subprocess_support
 from test.support.script_helper import assert_python_ok
 
 
@@ -85,6 +85,7 @@
     }
     """)
 
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def test_stdin_stdout(self):
         args = sys.executable, '-m', 'json.tool'
         process = subprocess.run(args, input=self.data, capture_output=True, text=True, check=True)
diff --git a/Lib/test/test_logging.py b/Lib/test/test_logging.py
index 74e950450c..dbcfc1ddd0 100644
--- a/Lib/test/test_logging.py
+++ b/Lib/test/test_logging.py
@@ -43,6 +43,7 @@
 import tempfile
 from test.support.script_helper import assert_python_ok, assert_python_failure
 from test import support
+from test.support import is_apple_mobile
 from test.support import os_helper
 from test.support import socket_helper
 from test.support import threading_helper
@@ -1776,9 +1777,20 @@
     # just need a name - file can't be present, or we'll get an
     # 'address already in use' error.
     os.remove(fn)
+    # Check the size of the socket file name. If it exceeds 108
+    # characters (UNIX_PATH_MAX), it can't be used as a UNIX socket.
+    # In this case, fall back to a path constructed somewhere that
+    # is known to be short.
+    if len(fn) > 108:
+        fd, fn = tempfile.mkstemp(prefix='test_logging_', suffix='.sock', dir='/tmp')
+        os.close(fd)
+        # just need a name - file can't be present, or we'll get an
+        # 'address already in use' error.
+        os.remove(fn)
     return fn
 
 @unittest.skipUnless(hasattr(socket, "AF_UNIX"), "Unix sockets required")
+@unittest.skipIf(is_apple_mobile, "%s doesn't fully support UNIX sockets." % sys.platform)
 class UnixSocketHandlerTest(SocketHandlerTest):
 
     """Test for SocketHandler with unix sockets."""
@@ -1860,6 +1872,7 @@
         self.assertEqual(self.log_output, "spam\neggs\n")
 
 @unittest.skipUnless(hasattr(socket, "AF_UNIX"), "Unix sockets required")
+@unittest.skipIf(is_apple_mobile, "%s doesn't fully support UNIX sockets." % sys.platform)
 class UnixDatagramHandlerTest(DatagramHandlerTest):
 
     """Test for DatagramHandler using Unix sockets."""
@@ -1944,6 +1957,7 @@
         self.assertEqual(self.log_output, b'<11>h\xc3\xa4m-sp\xc3\xa4m')
 
 @unittest.skipUnless(hasattr(socket, "AF_UNIX"), "Unix sockets required")
+@unittest.skipIf(is_apple_mobile, "%s doesn't fully support UNIX sockets." % sys.platform)
 class UnixSysLogHandlerTest(SysLogHandlerTest):
 
     """Test for SysLogHandler with Unix sockets."""
diff --git a/Lib/test/test_mailcap.py b/Lib/test/test_mailcap.py
index ef9cad498a..79d19aa860 100644
--- a/Lib/test/test_mailcap.py
+++ b/Lib/test/test_mailcap.py
@@ -1,8 +1,9 @@
 import mailcap
 import os
 import copy
+import sys
 import test.support
-from test.support import os_helper
+from test.support import os_helper, is_apple_mobile
 import unittest
 import sys
 
@@ -214,7 +215,8 @@
         ]
         self._run_cases(cases)
 
-    @unittest.skipUnless(os.name == "posix", "Requires 'test' command on system")
+    @unittest.skipUnless(os.name == "posix" and not is_apple_mobile,
+                         "Requires 'test' command on system")
     @unittest.skipIf(sys.platform == "vxworks", "'test' command is not supported on VxWorks")
     def test_test(self):
         # findmatch() will automatically check any "test" conditions and skip
diff --git a/Lib/test/test_marshal.py b/Lib/test/test_marshal.py
index 7bcf8e8399..5e808dc0b8 100644
--- a/Lib/test/test_marshal.py
+++ b/Lib/test/test_marshal.py
@@ -1,5 +1,5 @@
 from test import support
-from test.support import os_helper
+from test.support import os_helper, is_apple_mobile
 import array
 import io
 import marshal
@@ -234,7 +234,10 @@
         if os.name == 'nt':
             MAX_MARSHAL_STACK_DEPTH = 1000
         else:
-            MAX_MARSHAL_STACK_DEPTH = 2000
+            if is_apple_mobile:
+                MAX_MARSHAL_STACK_DEPTH = 1500
+            else:
+                MAX_MARSHAL_STACK_DEPTH = 2000
         for i in range(MAX_MARSHAL_STACK_DEPTH - 2):
             last.append([0])
             last = last[-1]
diff --git a/Lib/test/test_mmap.py b/Lib/test/test_mmap.py
index 8f34c182f8..95eb37140a 100644
--- a/Lib/test/test_mmap.py
+++ b/Lib/test/test_mmap.py
@@ -1,4 +1,6 @@
-from test.support import (requires, _2G, _4G, gc_collect, cpython_only)
+from test.support import (
+    requires, _2G, _4G, gc_collect, cpython_only, is_apple_mobile
+)
 from test.support.import_helper import import_module
 from test.support.os_helper import TESTFN, unlink
 import unittest
@@ -231,7 +233,7 @@
         with open(TESTFN, "r+b") as f:
             self.assertRaises(ValueError, mmap.mmap, f.fileno(), mapsize, access=4)
 
-        if os.name == "posix":
+        if os.name == "posix" and not is_apple_mobile:
             # Try incompatible flags, prot and access parameters.
             with open(TESTFN, "r+b") as f:
                 self.assertRaises(ValueError, mmap.mmap, f.fileno(), mapsize,
@@ -806,7 +808,7 @@
         unlink(TESTFN)
 
     def _make_test_file(self, num_zeroes, tail):
-        if sys.platform[:3] == 'win' or sys.platform == 'darwin':
+        if sys.platform[:3] == 'win' or sys.platform == 'darwin' or is_apple_mobile:
             requires('largefile',
                 'test requires %s bytes and a long time to run' % str(0x180000000))
         f = open(TESTFN, 'w+b')
diff --git a/Lib/test/test_multiprocessing_fork.py b/Lib/test/test_multiprocessing_fork.py
index 5000edb7c5..65a0fb67f9 100644
--- a/Lib/test/test_multiprocessing_fork.py
+++ b/Lib/test/test_multiprocessing_fork.py
@@ -1,4 +1,9 @@
 import unittest
+from test.support import has_subprocess_support
+
+if not has_subprocess_support:
+    raise unittest.SkipTest('Test requires support for subprocesses.')
+
 import test._test_multiprocessing
 
 import sys
diff --git a/Lib/test/test_multiprocessing_forkserver.py b/Lib/test/test_multiprocessing_forkserver.py
index 6ad5faf9e8..a5285ef77a 100644
--- a/Lib/test/test_multiprocessing_forkserver.py
+++ b/Lib/test/test_multiprocessing_forkserver.py
@@ -1,4 +1,9 @@
 import unittest
+from test.support import has_subprocess_support
+
+if not has_subprocess_support:
+    raise unittest.SkipTest('Test requires support for subprocesses.')
+
 import test._test_multiprocessing
 
 import sys
diff --git a/Lib/test/test_multiprocessing_spawn.py b/Lib/test/test_multiprocessing_spawn.py
index 6558952308..192096e2ac 100644
--- a/Lib/test/test_multiprocessing_spawn.py
+++ b/Lib/test/test_multiprocessing_spawn.py
@@ -1,4 +1,9 @@
 import unittest
+from test.support import has_subprocess_support
+
+if not has_subprocess_support:
+    raise unittest.SkipTest('Test requires support for subprocesses.')
+
 import test._test_multiprocessing
 
 from test import support
diff --git a/Lib/test/test_os.py b/Lib/test/test_os.py
index 1243b575dc..2c8ff44a99 100644
--- a/Lib/test/test_os.py
+++ b/Lib/test/test_os.py
@@ -32,6 +32,7 @@
 import warnings
 from test import support
 from test.support import import_helper
+from test.support import has_subprocess_support
 from test.support import os_helper
 from test.support import socket_helper
 from test.support import threading_helper
@@ -993,6 +994,7 @@
     @unittest.skipUnless(unix_shell and os.path.exists(unix_shell),
                          'requires a shell')
     @unittest.skipUnless(hasattr(os, 'popen'), "needs os.popen()")
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def test_update2(self):
         os.environ.clear()
         os.environ.update(HELLO="World")
@@ -1003,6 +1005,7 @@
     @unittest.skipUnless(unix_shell and os.path.exists(unix_shell),
                          'requires a shell')
     @unittest.skipUnless(hasattr(os, 'popen'), "needs os.popen()")
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def test_os_popen_iter(self):
         with os.popen("%s -c 'echo \"line1\nline2\nline3\"'"
                       % unix_shell) as popen:
@@ -1954,6 +1957,7 @@
 
 @unittest.skipUnless(hasattr(os, 'execv'),
                      "need os.execv()")
+@unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
 class ExecTests(unittest.TestCase):
     @unittest.skipIf(USING_LINUXTHREADS,
                      "avoid triggering a linuxthreads bug: see issue #4970")
@@ -2278,6 +2282,7 @@
         self.assertRaises(OverflowError, os.setreuid, 0, self.UID_OVERFLOW)
 
     @unittest.skipUnless(hasattr(os, 'setreuid'), 'test needs os.setreuid()')
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def test_setreuid_neg1(self):
         # Needs to accept -1.  We run this in a subprocess to avoid
         # altering the test runner's process state (issue8045).
@@ -2286,6 +2291,7 @@
                 'import os,sys;os.setreuid(-1,-1);sys.exit(0)'])
 
     @unittest.skipUnless(hasattr(os, 'setregid'), 'test needs os.setregid()')
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def test_setregid(self):
         if os.getuid() != 0 and not HAVE_WHEEL_GROUP:
             self.assertRaises(OSError, os.setregid, 0, 0)
@@ -2295,6 +2301,7 @@
         self.assertRaises(OverflowError, os.setregid, 0, self.GID_OVERFLOW)
 
     @unittest.skipUnless(hasattr(os, 'setregid'), 'test needs os.setregid()')
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def test_setregid_neg1(self):
         # Needs to accept -1.  We run this in a subprocess to avoid
         # altering the test runner's process state (issue8045).
@@ -2967,6 +2974,7 @@
 
 class PidTests(unittest.TestCase):
     @unittest.skipUnless(hasattr(os, 'getppid'), "test needs os.getppid")
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def test_getppid(self):
         p = subprocess.Popen([sys.executable, '-c',
                               'import os; print(os.getppid())'],
@@ -2993,6 +3001,7 @@
         self.assertEqual(os.waitstatus_to_exitcode(status), exitcode)
         self.assertEqual(pid2, pid)
 
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def test_waitpid(self):
         self.check_waitpid(code='pass', exitcode=0)
 
@@ -3662,6 +3671,7 @@
         self.assertGreaterEqual(size.columns, 0)
         self.assertGreaterEqual(size.lines, 0)
 
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def test_stty_match(self):
         """Check if stty returns the same results
 
diff --git a/Lib/test/test_pdb.py b/Lib/test/test_pdb.py
index 6ac1a4a3c3..178b8ab092 100644
--- a/Lib/test/test_pdb.py
+++ b/Lib/test/test_pdb.py
@@ -13,7 +13,7 @@
 
 from contextlib import ExitStack, redirect_stdout
 from io import StringIO
-from test.support import os_helper
+from test.support import os_helper, has_subprocess_support
 # This little helper class is essential for testing pdb under doctest.
 from test.test_doctest import _FakeInput
 from unittest.mock import patch
@@ -1356,6 +1356,7 @@
     def tearDown(self):
         os_helper.unlink(os_helper.TESTFN)
 
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def _run_pdb(self, pdb_args, commands):
         self.addCleanup(os_helper.rmtree, '__pycache__')
         cmd = [sys.executable, '-m', 'pdb'] + pdb_args
@@ -1448,6 +1449,7 @@
             ('bœr', 1),
         )
 
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def test_issue7964(self):
         # open the file as binary so we can force \r\n newline
         with open(os_helper.TESTFN, 'wb') as f:
diff --git a/Lib/test/test_pipes.py b/Lib/test/test_pipes.py
index 6335e7cbe0..9f424e67a3 100644
--- a/Lib/test/test_pipes.py
+++ b/Lib/test/test_pipes.py
@@ -1,15 +1,19 @@
 import pipes
 import os
 import string
+import sys
 import unittest
 import shutil
-from test.support import reap_children, unix_shell
+from test.support import reap_children, unix_shell, is_apple_mobile
 from test.support.os_helper import TESTFN, unlink
 
 
 if os.name != 'posix':
     raise unittest.SkipTest('pipes module only works on posix')
 
+if is_apple_mobile:
+    raise unittest.SkipTest('pipes tests cannot run on %s' % sys.platform)
+
 if not (unix_shell and os.path.exists(unix_shell)):
     raise unittest.SkipTest('pipes module requires a shell')
 
diff --git a/Lib/test/test_platform.py b/Lib/test/test_platform.py
index 1a688775f4..3ac10fbc26 100644
--- a/Lib/test/test_platform.py
+++ b/Lib/test/test_platform.py
@@ -8,7 +8,7 @@
 from unittest import mock
 
 from test import support
-from test.support import os_helper
+from test.support import os_helper, has_subprocess_support, is_apple_mobile
 
 FEDORA_OS_RELEASE = """\
 NAME=Fedora
@@ -79,6 +79,7 @@
         res = platform.architecture()
 
     @os_helper.skip_unless_symlink
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def test_architecture_via_symlink(self): # issue3762
         with support.PythonSymlink() as py:
             cmd = "-c", "import platform; print(platform.architecture())"
@@ -313,7 +314,7 @@
     def test_mac_ver(self):
         res = platform.mac_ver()
 
-        if platform.uname().system == 'Darwin':
+        if platform.uname().system == 'Darwin' and not is_apple_mobile:
             # We are on a macOS system, check that the right version
             # information is returned
             output = subprocess.check_output(['sw_vers'], text=True)
@@ -345,6 +346,10 @@
             else:
                 self.assertEqual(res[2], 'PowerPC')
 
+    @unittest.skipUnless(is_apple_mobile, "iOS/tvOS/watchOS only test")
+    def test_ios_ver(self):
+        res = platform.ios_ver()
+
 
     @unittest.skipUnless(sys.platform == 'darwin', "OSX only test")
     def test_mac_ver_with_fork(self):
diff --git a/Lib/test/test_poll.py b/Lib/test/test_poll.py
index 82bbb3af9f..485d7602a0 100644
--- a/Lib/test/test_poll.py
+++ b/Lib/test/test_poll.py
@@ -8,6 +8,7 @@
 import time
 import unittest
 from test.support import cpython_only
+from test.support import has_subprocess_support
 from test.support import threading_helper
 from test.support.os_helper import TESTFN
 
@@ -120,6 +121,7 @@
     # Another test case for poll().  This is copied from the test case for
     # select(), modified to use poll() instead.
 
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def test_poll2(self):
         cmd = 'for i in 0 1 2 3 4 5 6 7 8 9; do echo testing...; sleep 1; done'
         proc = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE,
diff --git a/Lib/test/test_popen.py b/Lib/test/test_popen.py
index cac2f6177f..467c1dbb13 100644
--- a/Lib/test/test_popen.py
+++ b/Lib/test/test_popen.py
@@ -5,6 +5,7 @@
 
 import unittest
 from test import support
+from test.support import has_subprocess_support
 import os, sys
 
 if not hasattr(os, 'popen'):
@@ -19,6 +20,8 @@
 if ' ' in python:
     python = '"' + python + '"'     # quote embedded space for cmdline
 
+
+@unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
 class PopenTest(unittest.TestCase):
 
     def _do_test_commandline(self, cmdline, expected):
diff --git a/Lib/test/test_posix.py b/Lib/test/test_posix.py
index 701543bb6a..dd6ad77088 100644
--- a/Lib/test/test_posix.py
+++ b/Lib/test/test_posix.py
@@ -2,6 +2,8 @@
 
 from test import support
 from test.support import import_helper
+from test.support import has_subprocess_support
+from test.support import is_apple_mobile
 from test.support import os_helper
 from test.support import warnings_helper
 from test.support.script_helper import assert_python_ok
@@ -64,15 +66,22 @@
         # no side-effects which we need to cleanup (e.g., fork, wait, abort)
         NO_ARG_FUNCTIONS = [ "ctermid", "getcwd", "getcwdb", "uname",
                              "times", "getloadavg",
-                             "getegid", "geteuid", "getgid", "getgroups",
+                             "getegid", "geteuid", "getgid",
                              "getpid", "getpgrp", "getppid", "getuid", "sync",
                            ]
 
+        # getgroups can't be invoked on iOS/tvOS/watchOS.
+        if is_apple_mobile:
+            NO_ARG_FUNCTIONS.append("getgroups")
+
         for name in NO_ARG_FUNCTIONS:
             posix_func = getattr(posix, name, None)
             if posix_func is not None:
-                posix_func()
-                self.assertRaises(TypeError, posix_func, 1)
+                try:
+                    posix_func()
+                    self.assertRaises(TypeError, posix_func, 1)
+                except Exception as e:
+                    self.fail('Problem invoking %s: %s' % (name, e))
 
     @unittest.skipUnless(hasattr(posix, 'getresuid'),
                          'test needs posix.getresuid()')
@@ -766,9 +775,10 @@
             check_stat(uid, gid)
             self.assertRaises(OSError, chown_func, first_param, 0, -1)
             check_stat(uid, gid)
-            if 0 not in os.getgroups():
-                self.assertRaises(OSError, chown_func, first_param, -1, 0)
-                check_stat(uid, gid)
+            if hasattr(os, 'getgroups') and not is_apple_mobile:
+                if 0 not in os.getgroups():
+                    self.assertRaises(OSError, chown_func, first_param, -1, 0)
+                    check_stat(uid, gid)
         # test illegal types
         for t in str, float:
             self.assertRaises(TypeError, chown_func, first_param, t(uid), gid)
@@ -1056,6 +1066,7 @@
 
     @unittest.skipUnless(hasattr(os, 'getegid'), "test needs os.getegid()")
     @unittest.skipUnless(hasattr(os, 'popen'), "test needs os.popen()")
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def test_getgroups(self):
         with os.popen('id -G 2>/dev/null') as idg:
             groups = idg.read().strip()
@@ -1114,7 +1125,7 @@
         self.assertIsInstance(hi, int)
         self.assertGreaterEqual(hi, lo)
         # OSX evidently just returns 15 without checking the argument.
-        if sys.platform != "darwin":
+        if sys.platform != 'darwin' and not is_apple_mobile:
             self.assertRaises(OSError, posix.sched_get_priority_min, -23)
             self.assertRaises(OSError, posix.sched_get_priority_max, -23)
 
diff --git a/Lib/test/test_pty.py b/Lib/test/test_pty.py
index 0243b8a30b..217534eaf1 100644
--- a/Lib/test/test_pty.py
+++ b/Lib/test/test_pty.py
@@ -1,4 +1,4 @@
-from test.support import verbose, reap_children
+from test.support import verbose, reap_children, has_subprocess_support
 from test.support.import_helper import import_module
 
 # Skip these tests if termios is not available
@@ -210,6 +210,7 @@
         s2 = _readline(master_fd)
         self.assertEqual(b'For my pet fish, Eric.\n', normalize_output(s2))
 
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def test_fork(self):
         debug("calling pty.fork()")
         pid, master_fd = pty.fork()
diff --git a/Lib/test/test_quopri.py b/Lib/test/test_quopri.py
index 715544c8a9..0641b2fcef 100644
--- a/Lib/test/test_quopri.py
+++ b/Lib/test/test_quopri.py
@@ -1,4 +1,5 @@
 import unittest
+from test.support import has_subprocess_support
 
 import sys, io, subprocess
 import quopri
@@ -180,6 +181,7 @@
         for p, e in self.HSTRINGS:
             self.assertEqual(quopri.decodestring(e, header=True), p)
 
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def test_scriptencode(self):
         (p, e) = self.STRINGS[-1]
         process = subprocess.Popen([sys.executable, "-mquopri"],
@@ -196,6 +198,7 @@
             self.assertEqual(cout[i], e[i])
         self.assertEqual(cout, e)
 
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def test_scriptdecode(self):
         (p, e) = self.STRINGS[-1]
         process = subprocess.Popen([sys.executable, "-mquopri", "-d"],
diff --git a/Lib/test/test_script_helper.py b/Lib/test/test_script_helper.py
index 4ade2cbc0d..63175fcc13 100644
--- a/Lib/test/test_script_helper.py
+++ b/Lib/test/test_script_helper.py
@@ -3,7 +3,7 @@
 import subprocess
 import sys
 import os
-from test.support import script_helper
+from test.support import script_helper, has_subprocess_support
 import unittest
 from unittest import mock
 
@@ -35,6 +35,7 @@
         self.assertIn('import sys; sys.exit(0)', error_msg,
                       msg='unexpected command line.')
 
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     @mock.patch('subprocess.Popen')
     def test_assert_python_isolated_when_env_not_required(self, mock_popen):
         with mock.patch.object(script_helper,
@@ -53,6 +54,7 @@
             self.assertIn('-I', popen_command)
             self.assertNotIn('-E', popen_command)  # -I overrides this
 
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     @mock.patch('subprocess.Popen')
     def test_assert_python_not_isolated_when_env_is_required(self, mock_popen):
         """Ensure that -I is not passed when the environment is required."""
@@ -82,6 +84,7 @@
         # Reset the private cached state.
         script_helper.__dict__['__cached_interp_requires_environment'] = None
 
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     @mock.patch('subprocess.check_call')
     def test_interpreter_requires_environment_true(self, mock_check_call):
         with mock.patch.dict(os.environ):
@@ -91,6 +94,7 @@
             self.assertTrue(script_helper.interpreter_requires_environment())
             self.assertEqual(1, mock_check_call.call_count)
 
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     @mock.patch('subprocess.check_call')
     def test_interpreter_requires_environment_false(self, mock_check_call):
         with mock.patch.dict(os.environ):
@@ -100,6 +104,7 @@
             self.assertFalse(script_helper.interpreter_requires_environment())
             self.assertEqual(1, mock_check_call.call_count)
 
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     @mock.patch('subprocess.check_call')
     def test_interpreter_requires_environment_details(self, mock_check_call):
         with mock.patch.dict(os.environ):
diff --git a/Lib/test/test_select.py b/Lib/test/test_select.py
index cf32cf2f6a..e28b80b766 100644
--- a/Lib/test/test_select.py
+++ b/Lib/test/test_select.py
@@ -6,6 +6,7 @@
 import textwrap
 import unittest
 from test import support
+from test.support import has_subprocess_support
 
 @unittest.skipIf((sys.platform[:3]=='win'),
                  "can't easily test on this system")
@@ -47,6 +48,7 @@
         self.assertIsNot(w, x)
 
     @unittest.skipUnless(hasattr(os, 'popen'), "need os.popen()")
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def test_select(self):
         code = textwrap.dedent('''
             import time
diff --git a/Lib/test/test_shutil.py b/Lib/test/test_shutil.py
index 62e9180375..7b94fa3355 100644
--- a/Lib/test/test_shutil.py
+++ b/Lib/test/test_shutil.py
@@ -30,7 +30,7 @@
     posix = None
 
 from test import support
-from test.support import os_helper
+from test.support import os_helper, has_subprocess_support
 from test.support.os_helper import TESTFN, FakePath
 
 TESTFN2 = TESTFN + "2"
@@ -1756,6 +1756,7 @@
             check_chown(dirname, uid, gid)
 
 
+@unittest.skipIf(support.has_subprocess_support, 'Test requires support for subprocesses.')
 class TestWhich(BaseTest, unittest.TestCase):
 
     def setUp(self):
@@ -2623,6 +2624,7 @@
         self.assertGreaterEqual(size.lines, 0)
 
     @unittest.skipUnless(os.isatty(sys.__stdout__.fileno()), "not on tty")
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     @unittest.skipUnless(hasattr(os, 'get_terminal_size'),
                          'need os.get_terminal_size()')
     def test_stty_match(self):
diff --git a/Lib/test/test_site.py b/Lib/test/test_site.py
index 93349ed8bb..5d207fa720 100644
--- a/Lib/test/test_site.py
+++ b/Lib/test/test_site.py
@@ -7,6 +7,7 @@
 import unittest
 import test.support
 from test import support
+from test.support import has_subprocess_support
 from test.support import os_helper
 from test.support import socket_helper
 from test.support import captured_stderr
@@ -210,6 +211,7 @@
 
     @unittest.skipUnless(site.ENABLE_USER_SITE, "requires access to PEP 370 "
                           "user-site (site.ENABLE_USER_SITE)")
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def test_s_option(self):
         # (ncoghlan) Change this to use script_helper...
         usersite = os.path.normpath(site.USER_SITE)
@@ -495,6 +497,7 @@
 
 class StartupImportTests(unittest.TestCase):
 
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def test_startup_imports(self):
         # Get sys.path in isolated mode (python3 -I)
         popen = subprocess.Popen([sys.executable, '-I', '-c',
diff --git a/Lib/test/test_socket.py b/Lib/test/test_socket.py
index e0e0f2437b..2e0b4a234d 100644
--- a/Lib/test/test_socket.py
+++ b/Lib/test/test_socket.py
@@ -1,5 +1,6 @@
 import unittest
 from test import support
+from test.support import is_apple_mobile
 from test.support import os_helper
 from test.support import socket_helper
 from test.support import threading_helper
@@ -1030,6 +1031,12 @@
             with self.assertRaises(OSError, msg=explanation):
                 socket.gethostbyaddr(addr)
 
+    @unittest.skipUnless(socket.has_ipv6, "test needs IPv6 support")
+    def test_host_resolution_ipv6(self):
+        for addr in ['::1q', '::1::2', '1:1:1:1:1:1:1:1:1']:
+            self.assertRaises(OSError, socket.gethostbyname, addr)
+            self.assertRaises(OSError, socket.gethostbyaddr, addr)
+
     @unittest.skipUnless(hasattr(socket, 'sethostname'), "test needs socket.sethostname()")
     @unittest.skipUnless(hasattr(socket, 'gethostname'), "test needs socket.gethostname()")
     def test_sethostname(self):
@@ -1142,7 +1149,7 @@
         # I've ordered this by protocols that have both a tcp and udp
         # protocol, at least for modern Linuxes.
         if (sys.platform.startswith(('freebsd', 'netbsd', 'gnukfreebsd'))
-            or sys.platform in ('linux', 'darwin')):
+            or sys.platform in ('linux', 'darwin') or is_apple_mobile):
             # avoid the 'echo' service on this platform, as there is an
             # assumption breaking non-standard port/protocol entry
             services = ('daytime', 'qotd', 'domain')
@@ -3509,7 +3516,7 @@
     def _testFDPassCMSG_LEN(self):
         self.createAndSendFDs(1)
 
-    @unittest.skipIf(sys.platform == "darwin", "skipping, see issue #12958")
+    @unittest.skipIf(sys.platform == "darwin" or is_apple_mobile, "skipping, see issue #12958")
     @unittest.skipIf(AIX, "skipping, see issue #22397")
     @requireAttrs(socket, "CMSG_SPACE")
     def testFDPassSeparate(self):
@@ -3520,7 +3527,7 @@
                              maxcmsgs=2)
 
     @testFDPassSeparate.client_skip
-    @unittest.skipIf(sys.platform == "darwin", "skipping, see issue #12958")
+    @unittest.skipIf(sys.platform == "darwin" or is_apple_mobile, "skipping, see issue #12958")
     @unittest.skipIf(AIX, "skipping, see issue #22397")
     def _testFDPassSeparate(self):
         fd0, fd1 = self.newFDs(2)
@@ -3533,7 +3540,7 @@
                                           array.array("i", [fd1]))]),
             len(MSG))
 
-    @unittest.skipIf(sys.platform == "darwin", "skipping, see issue #12958")
+    @unittest.skipIf(sys.platform == "darwin" or is_apple_mobile, "skipping, see issue #12958")
     @unittest.skipIf(AIX, "skipping, see issue #22397")
     @requireAttrs(socket, "CMSG_SPACE")
     def testFDPassSeparateMinSpace(self):
@@ -3547,7 +3554,7 @@
                              maxcmsgs=2, ignoreflags=socket.MSG_CTRUNC)
 
     @testFDPassSeparateMinSpace.client_skip
-    @unittest.skipIf(sys.platform == "darwin", "skipping, see issue #12958")
+    @unittest.skipIf(sys.platform == "darwin" or is_apple_mobile, "skipping, see issue #12958")
     @unittest.skipIf(AIX, "skipping, see issue #22397")
     def _testFDPassSeparateMinSpace(self):
         fd0, fd1 = self.newFDs(2)
@@ -3571,7 +3578,7 @@
             nbytes = self.sendmsgToServer([msg])
         self.assertEqual(nbytes, len(msg))
 
-    @unittest.skipIf(sys.platform == "darwin", "see issue #24725")
+    @unittest.skipIf(sys.platform == "darwin" or is_apple_mobile, "skipping, see issue #12958")
     def testFDPassEmpty(self):
         # Try to pass an empty FD array.  Can receive either no array
         # or an empty array.
@@ -4391,28 +4398,33 @@
     pass
 
 @requireAttrs(socket.socket, "sendmsg")
+@unittest.skipIf(is_apple_mobile, "%s doesn't fully support UNIX sockets." % sys.platform)
 @requireAttrs(socket, "AF_UNIX")
 class SendmsgUnixStreamTest(SendmsgStreamTests, SendrecvmsgUnixStreamTestBase):
     pass
 
 @requireAttrs(socket.socket, "recvmsg")
+@unittest.skipIf(is_apple_mobile, "%s doesn't fully support UNIX sockets." % sys.platform)
 @requireAttrs(socket, "AF_UNIX")
 class RecvmsgUnixStreamTest(RecvmsgTests, RecvmsgGenericStreamTests,
                             SendrecvmsgUnixStreamTestBase):
     pass
 
 @requireAttrs(socket.socket, "recvmsg_into")
+@unittest.skipIf(is_apple_mobile, "%s doesn't fully support UNIX sockets." % sys.platform)
 @requireAttrs(socket, "AF_UNIX")
 class RecvmsgIntoUnixStreamTest(RecvmsgIntoTests, RecvmsgGenericStreamTests,
                                 SendrecvmsgUnixStreamTestBase):
     pass
 
 @requireAttrs(socket.socket, "sendmsg", "recvmsg")
+@unittest.skipIf(is_apple_mobile, "%s doesn't fully support UNIX sockets." % sys.platform)
 @requireAttrs(socket, "AF_UNIX", "SOL_SOCKET", "SCM_RIGHTS")
 class RecvmsgSCMRightsStreamTest(SCMRightsTest, SendrecvmsgUnixStreamTestBase):
     pass
 
 @requireAttrs(socket.socket, "sendmsg", "recvmsg_into")
+@unittest.skipIf(is_apple_mobile, "%s doesn't fully support UNIX sockets." % sys.platform)
 @requireAttrs(socket, "AF_UNIX", "SOL_SOCKET", "SCM_RIGHTS")
 class RecvmsgIntoSCMRightsStreamTest(RecvmsgIntoMixin, SCMRightsTest,
                                      SendrecvmsgUnixStreamTestBase):
diff --git a/Lib/test/test_socketserver.py b/Lib/test/test_socketserver.py
index 211321f376..07f45e6749 100644
--- a/Lib/test/test_socketserver.py
+++ b/Lib/test/test_socketserver.py
@@ -8,13 +8,14 @@
 import select
 import signal
 import socket
+import sys
 import tempfile
 import threading
 import unittest
 import socketserver
 
 import test.support
-from test.support import reap_children, verbose
+from test.support import reap_children, verbose, has_subprocess_support, is_apple_mobile
 from test.support import os_helper
 from test.support import socket_helper
 from test.support import threading_helper
@@ -28,7 +29,7 @@
 HAVE_UNIX_SOCKETS = hasattr(socket, "AF_UNIX")
 requires_unix_sockets = unittest.skipUnless(HAVE_UNIX_SOCKETS,
                                             'requires Unix sockets')
-HAVE_FORKING = hasattr(os, "fork")
+HAVE_FORKING = hasattr(os, "fork") and has_subprocess_support
 requires_forking = unittest.skipUnless(HAVE_FORKING, 'requires forking')
 
 def signal_alarm(n):
@@ -196,12 +197,14 @@
                             self.stream_examine)
 
     @requires_unix_sockets
+    @unittest.skipIf(is_apple_mobile, "%s doesn't fully support UNIX sockets." % sys.platform)
     def test_UnixStreamServer(self):
         self.run_server(socketserver.UnixStreamServer,
                         socketserver.StreamRequestHandler,
                         self.stream_examine)
 
     @requires_unix_sockets
+    @unittest.skipIf(is_apple_mobile, "%s doesn't fully support UNIX sockets." % sys.platform)
     def test_ThreadingUnixStreamServer(self):
         self.run_server(socketserver.ThreadingUnixStreamServer,
                         socketserver.StreamRequestHandler,
diff --git a/Lib/test/test_source_encoding.py b/Lib/test/test_source_encoding.py
index a0cb605c16..838641f649 100644
--- a/Lib/test/test_source_encoding.py
+++ b/Lib/test/test_source_encoding.py
@@ -1,7 +1,7 @@
 # -*- coding: koi8-r -*-
 
 import unittest
-from test.support import script_helper, captured_stdout
+from test.support import script_helper, captured_stdout, has_subprocess_support
 from test.support.os_helper import TESTFN, unlink, rmtree
 from test.support.import_helper import unload
 import importlib
@@ -14,11 +14,11 @@
 
     def test_pep263(self):
         self.assertEqual(
-            "ðÉÔÏÎ".encode("utf-8"),
+            "ï¿½ï¿½ï¿½ï¿½ï¿½".encode("utf-8"),
             b'\xd0\x9f\xd0\xb8\xd1\x82\xd0\xbe\xd0\xbd'
         )
         self.assertEqual(
-            "\ð".encode("utf-8"),
+            "\ï¿½".encode("utf-8"),
             b'\\\xd0\x9f'
         )
 
@@ -65,6 +65,7 @@
         # two bytes in common with the UTF-8 BOM
         self.assertRaises(SyntaxError, eval, b'\xef\xbb\x20')
 
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def test_20731(self):
         sub = subprocess.Popen([sys.executable,
                         os.path.join(os.path.dirname(__file__),
diff --git a/Lib/test/test_subprocess.py b/Lib/test/test_subprocess.py
index b91791a02a..618a843390 100644
--- a/Lib/test/test_subprocess.py
+++ b/Lib/test/test_subprocess.py
@@ -24,6 +24,7 @@
 import textwrap
 import json
 import pathlib
+from test.support import has_subprocess_support
 from test.support.os_helper import FakePath
 
 try:
@@ -50,6 +51,9 @@
 
 mswindows = (sys.platform == "win32")
 
+if not has_subprocess_support:
+    raise unittest.SkipTest('Test requires support for subprocesses.')
+
 #
 # Depends on the following external programs: Python
 #
diff --git a/Lib/test/test_sundry.py b/Lib/test/test_sundry.py
index 007d68817c..b49f38fe2d 100644
--- a/Lib/test/test_sundry.py
+++ b/Lib/test/test_sundry.py
@@ -22,7 +22,8 @@
 
             import distutils.bcppcompiler
             import distutils.ccompiler
-            import distutils.cygwinccompiler
+            if sys.platform.startswith('win'):
+                import distutils.cygwinccompiler
             import distutils.filelist
             import distutils.text_file
             import distutils.unixccompiler
diff --git a/Lib/test/test_sys.py b/Lib/test/test_sys.py
index 1094d40849..ebeee34cfa 100644
--- a/Lib/test/test_sys.py
+++ b/Lib/test/test_sys.py
@@ -10,6 +10,7 @@
 import sysconfig
 import test.support
 from test import support
+from test.support import has_subprocess_support
 from test.support import os_helper
 from test.support.script_helper import assert_python_ok, assert_python_failure
 from test.support import threading_helper
@@ -633,6 +634,7 @@
     def test_clear_type_cache(self):
         sys._clear_type_cache()
 
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def test_ioencoding(self):
         env = dict(os.environ)
 
@@ -680,6 +682,7 @@
                          'requires OS support of non-ASCII encodings')
     @unittest.skipUnless(sys.getfilesystemencoding() == locale.getpreferredencoding(False),
                          'requires FS encoding to match locale')
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def test_ioencoding_nonascii(self):
         env = dict(os.environ)
 
@@ -692,6 +695,7 @@
 
     @unittest.skipIf(sys.base_prefix != sys.prefix,
                      'Test is not venv-compatible')
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def test_executable(self):
         # sys.executable should be absolute
         self.assertEqual(os.path.abspath(sys.executable), sys.executable)
@@ -726,6 +730,7 @@
             expected = None
         self.check_fsencoding(fs_encoding, expected)
 
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def c_locale_get_error_handler(self, locale, isolated=False, encoding=None):
         # Force the POSIX locale
         env = os.environ.copy()
diff --git a/Lib/test/test_sysconfig.py b/Lib/test/test_sysconfig.py
index 5ee9839c04..204a5c8a0f 100644
--- a/Lib/test/test_sysconfig.py
+++ b/Lib/test/test_sysconfig.py
@@ -5,7 +5,7 @@
 import shutil
 from copy import copy
 
-from test.support import (captured_stdout, PythonSymlink)
+from test.support import (captured_stdout, PythonSymlink, has_subprocess_support)
 from test.support.import_helper import import_module
 from test.support.os_helper import (TESTFN, unlink, skip_unless_symlink,
                                     change_cwd)
@@ -263,12 +263,13 @@
         self.assertTrue(os.path.isfile(config_h), config_h)
 
     def test_get_scheme_names(self):
-        wanted = ['nt', 'posix_home', 'posix_prefix']
+        wanted = ['nt', 'posix_home', 'posix_prefix', 'tvos', 'watchos']
         if HAS_USER_BASE:
             wanted.extend(['nt_user', 'osx_framework_user', 'posix_user'])
         self.assertEqual(get_scheme_names(), tuple(sorted(wanted)))
 
     @skip_unless_symlink
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def test_symlink(self): # Issue 7880
         with PythonSymlink() as py:
             cmd = "-c", "import sysconfig; print(sysconfig.get_platform())"
diff --git a/Lib/test/test_tempfile.py b/Lib/test/test_tempfile.py
index 1946b043d0..c3c21762cc 100644
--- a/Lib/test/test_tempfile.py
+++ b/Lib/test/test_tempfile.py
@@ -15,13 +15,14 @@
 
 import unittest
 from test import support
+from test_support import has_subprocess_support
 from test.support import os_helper
 from test.support import script_helper
 from test.support import warnings_helper
 
 
 has_textmode = (tempfile._text_openflags != tempfile._bin_openflags)
-has_spawnl = hasattr(os, 'spawnl')
+has_spawnl = hasattr(os, 'spawnl') and has_subprocess_support
 
 # TEST_FILES may need to be tweaked for systems depending on the maximum
 # number of files that can be opened at one time (see ulimit -n)
diff --git a/Lib/test/test_threading.py b/Lib/test/test_threading.py
index c54806e594..fc7cf8e1b2 100644
--- a/Lib/test/test_threading.py
+++ b/Lib/test/test_threading.py
@@ -3,7 +3,7 @@
 """
 
 import test.support
-from test.support import threading_helper
+from test.support import threading_helper, is_apple_mobile
 from test.support import verbose, cpython_only, os_helper
 from test.support.import_helper import import_module
 from test.support.script_helper import assert_python_ok, assert_python_failure
@@ -1142,6 +1142,7 @@
             os.set_blocking(r, False)
         return (r, w)
 
+    @unittest.skipIf(is_apple_mobile, "%s doesn't have os.pipe" % sys.platform)
     def test_threads_join(self):
         # Non-daemon threads should be joined at subinterpreter shutdown
         # (issue #18808)
@@ -1170,6 +1171,7 @@
         # The thread was joined properly.
         self.assertEqual(os.read(r, 1), b"x")
 
+    @unittest.skipIf(is_apple_mobile, "%s doesn't have os.pipe" % sys.platform)
     def test_threads_join_2(self):
         # Same as above, but a delay gets introduced after the thread's
         # Python code returned but before the thread state is deleted.
diff --git a/Lib/test/test_traceback.py b/Lib/test/test_traceback.py
index 18cd4aba24..d8c782de31 100644
--- a/Lib/test/test_traceback.py
+++ b/Lib/test/test_traceback.py
@@ -8,7 +8,7 @@
 import unittest
 import re
 from test import support
-from test.support import Error, captured_output, cpython_only, ALWAYS_EQ
+from test.support import Error, captured_output, cpython_only, ALWAYS_EQ, has_subprocess_support
 from test.support.os_helper import TESTFN, unlink
 from test.support.script_helper import assert_python_ok
 import textwrap
@@ -130,6 +130,7 @@
             str_name = '.'.join([X.__module__, X.__qualname__])
         self.assertEqual(err[0], "%s: %s\n" % (str_name, str_value))
 
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def test_encoded_file(self):
         # Test that tracebacks are correctly printed for encoded source files:
         # - correct line number (Issue2384)
diff --git a/Lib/test/test_unicodedata.py b/Lib/test/test_unicodedata.py
index 213b3cf252..9ffb25c012 100644
--- a/Lib/test/test_unicodedata.py
+++ b/Lib/test/test_unicodedata.py
@@ -12,7 +12,7 @@
 import unicodedata
 import unittest
 from test.support import (open_urlresource, requires_resource, script_helper,
-                          cpython_only, check_disallow_instantiation)
+                          cpython_only, check_disallow_instantiation, has_subprocess_support)
 
 
 class UnicodeMethodsTest(unittest.TestCase):
@@ -231,6 +231,7 @@
         # Ensure that the type disallows instantiation (bpo-43916)
         check_disallow_instantiation(self, unicodedata.UCD)
 
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def test_failed_import_during_compiling(self):
         # Issue 4367
         # Decoding \N escapes requires the unicodedata module. If it can't be
diff --git a/Lib/test/test_urllib2net.py b/Lib/test/test_urllib2net.py
index a7e7c9f0b9..cbe41898a0 100644
--- a/Lib/test/test_urllib2net.py
+++ b/Lib/test/test_urllib2net.py
@@ -11,6 +11,10 @@
 import urllib.error
 import urllib.request
 import sys
+try:
+    import ssl
+except ImportError:
+    ssl = None
 
 support.requires("network")
 
@@ -194,6 +198,7 @@
 
 ##             self._test_urls(urls, self._extra_handlers()+[bauth, dauth])
 
+    @unittest.skipIf(ssl is None, 'test requires ssl module')
     def test_urlwithfrag(self):
         urlwith_frag = "http://www.pythontest.net/index.html#frag"
         with socket_helper.transient_internet(urlwith_frag):
@@ -202,6 +207,7 @@
             self.assertEqual(res.geturl(),
                     "http://www.pythontest.net/index.html#frag")
 
+    @unittest.skipIf(ssl is None, 'test requires ssl module')
     def test_redirect_url_withfrag(self):
         redirect_url_with_frag = "http://www.pythontest.net/redir/with_frag/"
         with socket_helper.transient_internet(redirect_url_with_frag):
diff --git a/Lib/test/test_uuid.py b/Lib/test/test_uuid.py
index d6a8333427..a1ea672802 100755
--- a/Lib/test/test_uuid.py
+++ b/Lib/test/test_uuid.py
@@ -1,6 +1,6 @@
 import unittest
 from test import support
-from test.support import import_helper
+from test.support import import_helper, has_subprocess_support
 import builtins
 import contextlib
 import copy
@@ -640,6 +640,7 @@
             equal(str(u), v)
 
     @unittest.skipUnless(hasattr(os, 'fork'), 'need os.fork')
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def testIssue8621(self):
         # On at least some versions of OSX self.uuid.uuid4 generates
         # the same sequence of UUIDs in the parent and any
@@ -825,6 +826,7 @@
 
     @unittest.skipUnless(_uuid._ifconfig_getnode in _uuid._GETTERS,
         "ifconfig is not used for introspection on this platform")
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def test_ifconfig_getnode(self):
         node = self.uuid._ifconfig_getnode()
         self.check_node(node, 'ifconfig')
@@ -837,6 +839,7 @@
 
     @unittest.skipUnless(_uuid._arp_getnode in _uuid._GETTERS,
         "arp is not used for introspection on this platform")
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def test_arp_getnode(self):
         node = self.uuid._arp_getnode()
         self.check_node(node, 'arp')
@@ -849,6 +852,7 @@
 
     @unittest.skipUnless(_uuid._netstat_getnode in _uuid._GETTERS,
         "netstat is not used for introspection on this platform")
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def test_netstat_getnode(self):
         node = self.uuid._netstat_getnode()
         self.check_node(node, 'netstat')
diff --git a/Lib/test/test_venv.py b/Lib/test/test_venv.py
index eca35ec4bf..84863d1d51 100644
--- a/Lib/test/test_venv.py
+++ b/Lib/test/test_venv.py
@@ -16,7 +16,7 @@
 import sys
 import tempfile
 from test.support import (captured_stdout, captured_stderr, requires_zlib,
-                          skip_if_broken_multiprocessing_synchronize)
+                          skip_if_broken_multiprocessing_synchronize, has_subprocess_support)
 from test.support.os_helper import (can_symlink, EnvironmentVarGuard, rmtree)
 import unittest
 import venv
@@ -179,6 +179,7 @@
                 builder.upgrade_dependencies(fake_context)
 
     @requireVenvCreate
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def test_prefixes(self):
         """
         Test that the prefix values are as expected.
@@ -316,6 +317,7 @@
     # point to the venv being used to run the test, and we lose the link
     # to the source build - so Python can't initialise properly.
     @requireVenvCreate
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def test_executable(self):
         """
         Test that the sys.executable value is as expected.
@@ -329,6 +331,7 @@
         self.assertEqual(out.strip(), envpy.encode())
 
     @unittest.skipUnless(can_symlink(), 'Needs symlinks')
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def test_executable_symlinks(self):
         """
         Test that the sys.executable value is as expected.
@@ -414,6 +417,7 @@
 @requireVenvCreate
 class EnsurePipTest(BaseTest):
     """Test venv module installation of pip."""
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def assert_pip_not_installed(self):
         envpy = os.path.join(os.path.realpath(self.env_dir),
                              self.bindir, self.exe)
@@ -557,6 +561,7 @@
 
     # Issue #26610: pip/pep425tags.py requires ctypes
     @unittest.skipUnless(ctypes, 'pip requires ctypes')
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     @requires_zlib()
     def test_with_pip(self):
         self.do_test_with_pip(False)
diff --git a/Lib/test/test_webbrowser.py b/Lib/test/test_webbrowser.py
index 673cc995d3..bd8a48e694 100644
--- a/Lib/test/test_webbrowser.py
+++ b/Lib/test/test_webbrowser.py
@@ -6,9 +6,14 @@
 from unittest import mock
 from test import support
 from test.support import import_helper
+from test.support import is_apple_mobile
 from test.support import os_helper
 
 
+if is_apple_mobile:
+    raise unittest.SkipTest("Can't run webbrowser tests on %s" % sys.platform)
+
+
 URL = 'http://www.example.com'
 CMD_NAME = 'test'
 
diff --git a/Lib/test/test_zipfile.py b/Lib/test/test_zipfile.py
index e557d569a1..2be2a96b73 100644
--- a/Lib/test/test_zipfile.py
+++ b/Lib/test/test_zipfile.py
@@ -1162,6 +1162,7 @@
             self.skipTest('requires write access to the installed location')
         unlink(filename)
 
+    @unittest.skipIf(sys.dont_write_bytecode, "Test requires ability to write bytecode")
     def test_write_pyfile(self):
         self.requiresWriteAccess(os.path.dirname(__file__))
         with TemporaryFile() as t, zipfile.PyZipFile(t, "w") as zipfp:
@@ -1206,6 +1207,7 @@
             self.assertCompiledIn('email/__init__.py', names)
             self.assertCompiledIn('email/mime/text.py', names)
 
+    @unittest.skipIf(sys.dont_write_bytecode, "Test requires ability to write bytecode")
     def test_write_filtered_python_package(self):
         import test
         packagedir = os.path.dirname(test.__file__)
diff --git a/Lib/unittest/test/test_runner.py b/Lib/unittest/test/test_runner.py
index 453e6c3d11..dd9880f1d8 100644
--- a/Lib/unittest/test/test_runner.py
+++ b/Lib/unittest/test/test_runner.py
@@ -9,6 +9,7 @@
 
 from unittest.test.support import (LoggingResult,
                                    ResultWithNoStartTestRunStopTestRun)
+from test.support import has_subprocess_support
 
 
 def resultFactory(*_):
@@ -1135,6 +1136,7 @@
         expectedresult = (runner.stream, DESCRIPTIONS, VERBOSITY)
         self.assertEqual(runner._makeResult(), expectedresult)
 
+    @unittest.skipUnless(has_subprocess_support, 'Test requires support for subprocesses.')
     def test_warnings(self):
         """
         Check that warnings argument of TextTestRunner correctly affects the
diff --git a/Lib/webbrowser.py b/Lib/webbrowser.py
index ec3cece48c..8a79db0722 100755
--- a/Lib/webbrowser.py
+++ b/Lib/webbrowser.py
@@ -594,6 +594,57 @@
 
     # what to do if _tryorder is now empty?
 
+#
+# Platform support for iOS
+#
+if sys.platform == 'ios':
+    class MobileSafari(BaseBrowser):
+        def open(self, url, new=0, autoraise=True):
+            # This code is the equivalent of:
+            #   NSURL *nsurl = [NSURL URLWithString:url];
+            #   [[UIApplication sharedApplication] openURL:nsurl];
+            from ctypes import cdll, c_void_p, c_char_p, c_uint32
+            from ctypes import util
+            objc = cdll.LoadLibrary(util.find_library(b'objc'))
+            cf = cdll.LoadLibrary(util.find_library(b'CoreFoundation'))
+            objc.objc_getClass.restype = c_void_p
+            objc.objc_getClass.argtypes = [c_char_p]
+            objc.sel_registerName.restype = c_void_p
+            objc.sel_registerName.argtypes = [c_char_p]
+            cf.CFStringCreateWithCString.restype = c_void_p
+            cf.CFStringCreateWithCString.argtypes = [c_void_p, c_char_p, c_uint32]
+
+            # Get an NSString describing the URL
+            kCFStringEncodingUTF8 = 0x08000100
+            url = c_void_p(cf.CFStringCreateWithCString(None, url.encode('utf-8'), kCFStringEncodingUTF8))
+            autorelease = c_void_p(objc.sel_registerName(b'autorelease'))
+            objc.objc_msgSend.argtypes = [c_void_p, c_void_p]
+            objc.objc_msgSend.restype = c_void_p
+            objc.objc_msgSend(url, autorelease)
+
+            # Get an NSURL object representing the URL
+            NSURL = c_void_p(objc.objc_getClass(b'NSURL'))
+            urlWithString_ = c_void_p(objc.sel_registerName(b'URLWithString:'))
+            objc.objc_msgSend.restype = c_void_p
+            objc.objc_msgSend.argtypes = [c_void_p, c_void_p, c_void_p]
+            nsurl = c_void_p(objc.objc_msgSend(NSURL, urlWithString_, url))
+
+            # Get the shared UIApplication instance
+            UIApplication = c_void_p(objc.objc_getClass(b'UIApplication'))
+            sharedApplication = c_void_p(objc.sel_registerName(b'sharedApplication'))
+            objc.objc_msgSend.argtypes = [c_void_p, c_void_p]
+            objc.objc_msgSend.restype = c_void_p
+            shared_app = c_void_p(objc.objc_msgSend(UIApplication, sharedApplication))
+
+            # Open the URL on the shared application
+            openURL_ = c_void_p(objc.sel_registerName(b'openURL:'))
+            objc.objc_msgSend.argtypes = [c_void_p, c_void_p, c_void_p]
+            objc.objc_msgSend.restype = None
+            objc.objc_msgSend(shared_app, openURL_, nsurl)
+
+            return True
+
+    register("mobilesafari", None, MobileSafari(), preferred=True)
 
 #
 # Platform support for Windows
diff --git a/Makefile.pre.in b/Makefile.pre.in
index ee85f35b10..df7913ff5a 100644
--- a/Makefile.pre.in
+++ b/Makefile.pre.in
@@ -307,6 +307,8 @@
 ##########################################################################
 
 LIBFFI_INCLUDEDIR=	@LIBFFI_INCLUDEDIR@
+LIBFFI_LIBDIR=	@LIBFFI_LIBDIR@
+LIBFFI_LIB=@LIBFFI_LIB@
 
 ##########################################################################
 # Parser
diff --git a/Modules/_posixsubprocess.c b/Modules/_posixsubprocess.c
index b852ad71d7..631ca5ebb8 100644
--- a/Modules/_posixsubprocess.c
+++ b/Modules/_posixsubprocess.c
@@ -599,11 +599,15 @@
     saved_errno = 0;
     for (i = 0; exec_array[i] != NULL; ++i) {
         const char *executable = exec_array[i];
+#if defined(__ENVIRONMENT_TV_OS_VERSION_MIN_REQUIRED__) || defined(__ENVIRONMENT_WATCH_OS_VERSION_MIN_REQUIRED__)
+	errno = ENOTSUP;
+#else
         if (envp) {
             execve(executable, argv, envp);
         } else {
             execv(executable, argv);
         }
+#endif
         if (errno != ENOENT && errno != ENOTDIR && saved_errno == 0) {
             saved_errno = errno;
         }
@@ -690,7 +694,11 @@
     } else
 #endif
     {
+#if defined(__ENVIRONMENT_TV_OS_VERSION_MIN_REQUIRED__) || defined(__ENVIRONMENT_WATCH_OS_VERSION_MIN_REQUIRED__)
+        pid = -1;
+#else
         pid = fork();
+#endif
     }
 
     if (pid != 0) {
diff --git a/Modules/faulthandler.c b/Modules/faulthandler.c
index 4af8702068..98825e5156 100644
--- a/Modules/faulthandler.c
+++ b/Modules/faulthandler.c
@@ -1,3 +1,7 @@
+#ifdef __APPLE__
+#  include "TargetConditionals.h"
+#endif /* __APPLE__ */
+
 #include "Python.h"
 #include "pycore_initconfig.h"    // _PyStatus_ERR
 #include "pycore_pyerrors.h"      // _Py_DumpExtensionModules
@@ -17,6 +21,11 @@
 #  include <sys/resource.h>
 #endif
 
+// tvOS and watchOS don't provide a number of important POSIX functions.
+#if defined(__ENVIRONMENT_TV_OS_VERSION_MIN_REQUIRED__) || defined(__ENVIRONMENT_WATCH_OS_VERSION_MIN_REQUIRED__)
+#  undef HAVE_SIGALTSTACK
+#endif /* TVOS || WATCHOS */
+
 /* Using an alternative stack requires sigaltstack()
    and sigaction() SA_ONSTACK */
 #if defined(HAVE_SIGALTSTACK) && defined(HAVE_SIGACTION)
diff --git a/Modules/mathmodule.c b/Modules/mathmodule.c
index 4534176adc..0255bcfd72 100644
--- a/Modules/mathmodule.c
+++ b/Modules/mathmodule.c
@@ -66,6 +66,10 @@
 /*[clinic end generated code: output=da39a3ee5e6b4b0d input=76bc7002685dd942]*/
 
 
+#ifdef __APPLE__
+#  include "TargetConditionals.h"
+#endif /* __APPLE__ */
+
 /*
    sin(pi*x), giving accurate results for all finite x (especially x
    integral or close to an integer).  This is here for use in the
diff --git a/Modules/posixmodule.c b/Modules/posixmodule.c
index 3d74b22f72..63c8b58bd0 100644
--- a/Modules/posixmodule.c
+++ b/Modules/posixmodule.c
@@ -63,6 +63,8 @@
  */
 #if defined(__APPLE__)
 
+#include "TargetConditionals.h"
+
 #if defined(__has_builtin)
 #if __has_builtin(__builtin_available)
 #define HAVE_BUILTIN_AVAILABLE 1
@@ -182,7 +184,6 @@
 disguised Unix interface).  Refer to the library manual and\n\
 corresponding Unix manual entries for more information on calls.");
 
-
 #ifdef HAVE_SYS_UIO_H
 #  include <sys/uio.h>
 #endif
@@ -339,6 +340,26 @@
 #  endif  /* _MSC_VER */
 #endif  /* ! __WATCOMC__ || __QNX__ */
 
+// iOS/tvOS/watchOS *define* a number of POSIX functions, but you can't use them
+// because iOS isn't a conventional multiprocess environment.
+#if TARGET_OS_IPHONE
+#  undef HAVE_EXECV
+#  undef HAVE_FORK
+#  undef HAVE_FORK1
+#  undef HAVE_FORKPTY
+#  undef HAVE_GETGROUPS
+#  undef HAVE_POSIX_SPAWN
+#  undef HAVE_POSIX_SPAWNP
+#  undef HAVE_SCHED_H
+#  undef HAVE_SENDFILE
+#  undef HAVE_SETPRIORITY
+#  undef HAVE_SPAWNV
+#  undef HAVE_WAIT
+#  undef HAVE_WAIT3
+#  undef HAVE_WAIT4
+#  undef HAVE_WAITPID
+#endif
+
 _Py_IDENTIFIER(__fspath__);
 
 /*[clinic input]
@@ -567,27 +588,33 @@
         }
     }
 }
+#endif
 
 void
 PyOS_BeforeFork(void)
 {
+#ifdef HAVE_FORK
     run_at_forkers(_PyInterpreterState_GET()->before_forkers, 1);
 
     _PyImport_AcquireLock();
+#endif
 }
 
 void
 PyOS_AfterFork_Parent(void)
 {
+#ifdef HAVE_FORK
     if (_PyImport_ReleaseLock() <= 0)
         Py_FatalError("failed releasing import lock after fork");
 
     run_at_forkers(_PyInterpreterState_GET()->after_forkers_parent, 0);
+#endif
 }
 
 void
 PyOS_AfterFork_Child(void)
 {
+#ifdef HAVE_FORK
     PyStatus status;
     _PyRuntimeState *runtime = &_PyRuntime;
 
@@ -627,8 +654,10 @@
 
 fatal_error:
     Py_ExitStatusException(status);
+#endif
 }
 
+#ifdef HAVE_FORK
 static int
 register_at_forker(PyObject **lst, PyObject *func)
 {
@@ -648,9 +677,7 @@
 void
 PyOS_AfterFork(void)
 {
-#ifdef HAVE_FORK
     PyOS_AfterFork_Child();
-#endif
 }
 
 
@@ -1588,7 +1615,9 @@
 */
 #include <crt_externs.h>
 #elif !defined(_MSC_VER) && (!defined(__WATCOMC__) || defined(__QNX__) || defined(__VXWORKS__))
+#  if !TARGET_OS_TV && !TARGET_OS_WATCH
 extern char **environ;
+#  endif
 #endif /* !_MSC_VER */
 
 static PyObject *
@@ -1604,6 +1633,7 @@
     d = PyDict_New();
     if (d == NULL)
         return NULL;
+#if !TARGET_OS_TV && !TARGET_OS_WATCH
 #ifdef MS_WINDOWS
     /* _wenviron must be initialized in this way if the program is started
        through main() instead of wmain(). */
@@ -1657,6 +1687,7 @@
         Py_DECREF(k);
         Py_DECREF(v);
     }
+#endif
     return d;
 }
 
@@ -4869,6 +4900,9 @@
 /*[clinic end generated code: output=290fc437dd4f33a0 input=86a58554ba6094af]*/
 {
     long result;
+#if TARGET_OS_IPHONE
+    result = -1;
+#else
     const char *bytes = PyBytes_AsString(command);
 
     if (PySys_Audit("os.system", "(O)", command) < 0) {
@@ -4878,6 +4912,7 @@
     Py_BEGIN_ALLOW_THREADS
     result = system(bytes);
     Py_END_ALLOW_THREADS
+#endif
     return result;
 }
 #endif
@@ -13601,6 +13636,7 @@
     int is_symlink;
     int need_stat;
 #endif
+#if !TARGET_OS_TV && !TARGET_OS_WATCH
 #ifdef MS_WINDOWS
     unsigned long dir_bits;
 #endif
@@ -13661,6 +13697,7 @@
 #endif
 
     return result;
+#endif
 
 error:
     Py_XDECREF(st_mode);
diff --git a/Modules/pwdmodule.c b/Modules/pwdmodule.c
index 14d3f9dcb1..5c0ad6db8d 100644
--- a/Modules/pwdmodule.c
+++ b/Modules/pwdmodule.c
@@ -1,6 +1,10 @@
 
 /* UNIX password file access module */
 
+#ifdef __APPLE__
+#  include "TargetConditionals.h"
+#endif /* __APPLE__ */
+
 #include "Python.h"
 #include "posixmodule.h"
 
@@ -184,6 +188,22 @@
         if (nomem == 1) {
             return PyErr_NoMemory();
         }
+
+// iPhone has a "user" with UID 501, username "mobile"; but the simulator
+// doesn't reflect this. Generate a simulated response.
+#if TARGET_IPHONE_SIMULATOR
+        if (uid == 501) {
+            struct passwd mp;
+            mp.pw_name = "mobile";
+            mp.pw_passwd = "/smx7MYTQIi2M";
+            mp.pw_uid = 501;
+            mp.pw_gid = 501;
+            mp.pw_gecos = "Mobile User";
+            mp.pw_dir = "/var/mobile";
+            mp.pw_shell = "/bin/sh";
+            return mkpwent(module, &mp);
+        }
+#endif
         PyObject *uid_obj = _PyLong_FromUid(uid);
         if (uid_obj == NULL)
             return NULL;
@@ -267,6 +287,22 @@
             PyErr_NoMemory();
         }
         else {
+// iPhone has a "user" with UID 501, username "mobile"; but the simulator
+// doesn't reflect this. Generate a simulated response.
+#if TARGET_IPHONE_SIMULATOR
+            if (strcmp(name, "mobile") == 0) {
+                struct passwd mp;
+                mp.pw_name = "mobile";
+                mp.pw_passwd = "/smx7MYTQIi2M";
+                mp.pw_uid = 501;
+                mp.pw_gid = 501;
+                mp.pw_gecos = "Mobile User";
+                mp.pw_dir = "/var/mobile";
+                mp.pw_shell = "/bin/sh";
+                retval = mkpwent(module, &mp);
+                goto out;
+            }
+#endif
             PyErr_Format(PyExc_KeyError,
                          "getpwnam(): name not found: %R", name);
         }
diff --git a/Modules/timemodule.c b/Modules/timemodule.c
index 4caacc3b64..6abe21545d 100644
--- a/Modules/timemodule.c
+++ b/Modules/timemodule.c
@@ -62,6 +62,11 @@
 
 #define SEC_TO_NS (1000 * 1000 * 1000)
 
+#ifdef __APPLE__
+#  include "TargetConditionals.h"
+#endif /* __APPLE__ */
+
+
 /* Forward declarations */
 static int pysleep(_PyTime_t);
 
@@ -250,11 +255,13 @@
     if (_PyTime_AsTimespec(t, &tp) == -1)
         return NULL;
 
+#if !TARGET_OS_IPHONE
     ret = clock_settime((clockid_t)clk_id, &tp);
     if (ret != 0) {
         PyErr_SetFromErrno(PyExc_OSError);
         return NULL;
     }
+#endif
     Py_RETURN_NONE;
 }
 
@@ -283,11 +290,13 @@
         return NULL;
     }
 
+#if !TARGET_OS_IPHONE
     ret = clock_settime((clockid_t)clk_id, &ts);
     if (ret != 0) {
         PyErr_SetFromErrno(PyExc_OSError);
         return NULL;
     }
+#endif
     Py_RETURN_NONE;
 }
 
diff --git a/Python/bootstrap_hash.c b/Python/bootstrap_hash.c
index e189ce0d90..5a53988ffa 100644
--- a/Python/bootstrap_hash.c
+++ b/Python/bootstrap_hash.c
@@ -35,6 +35,10 @@
 #endif
 
 
+#ifdef __APPLE__
+#  include "TargetConditionals.h"
+#endif /* __APPLE__ */
+
 #ifdef Py_DEBUG
 int _Py_HashSecret_Initialized = 0;
 #else
@@ -205,6 +209,9 @@
 }
 
 #elif defined(HAVE_GETENTROPY)
+// iOS, tvOS and watchOS have an incomplete definitions of getentropy
+// so it is *found* by configure, but doesn't actually exist.
+#elif defined(HAVE_GETENTROPY) && !TARGET_OS_IPHONE
 #define PY_GETENTROPY 1
 
 /* Fill buffer with size pseudo-random bytes generated by getentropy():
diff --git a/Python/marshal.c b/Python/marshal.c
index 4125240606..317a576566 100644
--- a/Python/marshal.c
+++ b/Python/marshal.c
@@ -14,6 +14,10 @@
 #include "marshal.h"
 #include "pycore_hashtable.h"
 
+#ifdef __APPLE__
+#  include "TargetConditionals.h"
+#endif /* __APPLE__ */
+
 /*[clinic input]
 module marshal
 [clinic start generated code]*/
@@ -33,9 +37,13 @@
  * #if defined(MS_WINDOWS) && defined(_DEBUG)
  */
 #if defined(MS_WINDOWS)
-#define MAX_MARSHAL_STACK_DEPTH 1000
+#  define MAX_MARSHAL_STACK_DEPTH 1000
 #else
-#define MAX_MARSHAL_STACK_DEPTH 2000
+#  if TARGET_OS_IPHONE
+#    define MAX_MARSHAL_STACK_DEPTH 1500
+#  else
+#    define MAX_MARSHAL_STACK_DEPTH 2000
+#  endif
 #endif
 
 #define TYPE_NULL               '0'
diff --git a/aclocal.m4 b/aclocal.m4
index 2f1bd37528..a63e6654da 100644
--- a/aclocal.m4
+++ b/aclocal.m4
@@ -1,6 +1,6 @@
-# generated automatically by aclocal 1.16.3 -*- Autoconf -*-
+# generated automatically by aclocal 1.16.5 -*- Autoconf -*-
 
-# Copyright (C) 1996-2020 Free Software Foundation, Inc.
+# Copyright (C) 1996-2021 Free Software Foundation, Inc.
 
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -184,7 +184,7 @@
 #   and this notice are preserved. This file is offered as-is, without any
 #   warranty.
 
-#serial 10
+#serial 11
 
 AU_ALIAS([CHECK_SSL], [AX_CHECK_OPENSSL])
 AC_DEFUN([AX_CHECK_OPENSSL], [
@@ -227,7 +227,7 @@
     if ! $found; then
         OPENSSL_INCLUDES=
         for ssldir in $ssldirs; do
-            AC_MSG_CHECKING([for openssl/ssl.h in $ssldir])
+            AC_MSG_CHECKING([for include/openssl/ssl.h in $ssldir])
             if test -f "$ssldir/include/openssl/ssl.h"; then
                 OPENSSL_INCLUDES="-I$ssldir/include"
                 OPENSSL_LDFLAGS="-L$ssldir/lib"
@@ -276,7 +276,7 @@
 ])
 
 # pkg.m4 - Macros to locate and utilise pkg-config.   -*- Autoconf -*-
-# serial 11 (pkg-config-0.29.1)
+# serial 12 (pkg-config-0.29.2)
 
 dnl Copyright © 2004 Scott James Remnant <scott@netsplit.com>.
 dnl Copyright © 2012-2015 Dan Nicholson <dbn.lists@gmail.com>
@@ -318,7 +318,7 @@
 dnl See the "Since" comment for each macro you use to see what version
 dnl of the macros you require.
 m4_defun([PKG_PREREQ],
-[m4_define([PKG_MACROS_VERSION], [0.29.1])
+[m4_define([PKG_MACROS_VERSION], [0.29.2])
 m4_if(m4_version_compare(PKG_MACROS_VERSION, [$1]), -1,
     [m4_fatal([pkg.m4 version $1 or higher is required but ]PKG_MACROS_VERSION[ found])])
 ])dnl PKG_PREREQ
@@ -419,7 +419,7 @@
 AC_ARG_VAR([$1][_LIBS], [linker flags for $1, overriding pkg-config])dnl
 
 pkg_failed=no
-AC_MSG_CHECKING([for $1])
+AC_MSG_CHECKING([for $2])
 
 _PKG_CONFIG([$1][_CFLAGS], [cflags], [$2])
 _PKG_CONFIG([$1][_LIBS], [libs], [$2])
@@ -429,11 +429,11 @@
 See the pkg-config man page for more details.])
 
 if test $pkg_failed = yes; then
-   	AC_MSG_RESULT([no])
+        AC_MSG_RESULT([no])
         _PKG_SHORT_ERRORS_SUPPORTED
         if test $_pkg_short_errors_supported = yes; then
 	        $1[]_PKG_ERRORS=`$PKG_CONFIG --short-errors --print-errors --cflags --libs "$2" 2>&1`
-        else 
+        else
 	        $1[]_PKG_ERRORS=`$PKG_CONFIG --print-errors --cflags --libs "$2" 2>&1`
         fi
 	# Put the nasty error message in config.log where it belongs
@@ -450,7 +450,7 @@
 _PKG_TEXT])[]dnl
         ])
 elif test $pkg_failed = untried; then
-     	AC_MSG_RESULT([no])
+        AC_MSG_RESULT([no])
 	m4_default([$4], [AC_MSG_FAILURE(
 [The pkg-config script could not be found or is too old.  Make sure it
 is in your PATH or set the PKG_CONFIG environment variable to the full
@@ -551,71 +551,3 @@
 AS_VAR_IF([$1], [""], [$5], [$4])dnl
 ])dnl PKG_CHECK_VAR
 
-dnl PKG_WITH_MODULES(VARIABLE-PREFIX, MODULES,
-dnl   [ACTION-IF-FOUND],[ACTION-IF-NOT-FOUND],
-dnl   [DESCRIPTION], [DEFAULT])
-dnl ------------------------------------------
-dnl
-dnl Prepare a "--with-" configure option using the lowercase
-dnl [VARIABLE-PREFIX] name, merging the behaviour of AC_ARG_WITH and
-dnl PKG_CHECK_MODULES in a single macro.
-AC_DEFUN([PKG_WITH_MODULES],
-[
-m4_pushdef([with_arg], m4_tolower([$1]))
-
-m4_pushdef([description],
-           [m4_default([$5], [build with ]with_arg[ support])])
-
-m4_pushdef([def_arg], [m4_default([$6], [auto])])
-m4_pushdef([def_action_if_found], [AS_TR_SH([with_]with_arg)=yes])
-m4_pushdef([def_action_if_not_found], [AS_TR_SH([with_]with_arg)=no])
-
-m4_case(def_arg,
-            [yes],[m4_pushdef([with_without], [--without-]with_arg)],
-            [m4_pushdef([with_without],[--with-]with_arg)])
-
-AC_ARG_WITH(with_arg,
-     AS_HELP_STRING(with_without, description[ @<:@default=]def_arg[@:>@]),,
-    [AS_TR_SH([with_]with_arg)=def_arg])
-
-AS_CASE([$AS_TR_SH([with_]with_arg)],
-            [yes],[PKG_CHECK_MODULES([$1],[$2],$3,$4)],
-            [auto],[PKG_CHECK_MODULES([$1],[$2],
-                                        [m4_n([def_action_if_found]) $3],
-                                        [m4_n([def_action_if_not_found]) $4])])
-
-m4_popdef([with_arg])
-m4_popdef([description])
-m4_popdef([def_arg])
-
-])dnl PKG_WITH_MODULES
-
-dnl PKG_HAVE_WITH_MODULES(VARIABLE-PREFIX, MODULES,
-dnl   [DESCRIPTION], [DEFAULT])
-dnl -----------------------------------------------
-dnl
-dnl Convenience macro to trigger AM_CONDITIONAL after PKG_WITH_MODULES
-dnl check._[VARIABLE-PREFIX] is exported as make variable.
-AC_DEFUN([PKG_HAVE_WITH_MODULES],
-[
-PKG_WITH_MODULES([$1],[$2],,,[$3],[$4])
-
-AM_CONDITIONAL([HAVE_][$1],
-               [test "$AS_TR_SH([with_]m4_tolower([$1]))" = "yes"])
-])dnl PKG_HAVE_WITH_MODULES
-
-dnl PKG_HAVE_DEFINE_WITH_MODULES(VARIABLE-PREFIX, MODULES,
-dnl   [DESCRIPTION], [DEFAULT])
-dnl ------------------------------------------------------
-dnl
-dnl Convenience macro to run AM_CONDITIONAL and AC_DEFINE after
-dnl PKG_WITH_MODULES check. HAVE_[VARIABLE-PREFIX] is exported as make
-dnl and preprocessor variable.
-AC_DEFUN([PKG_HAVE_DEFINE_WITH_MODULES],
-[
-PKG_HAVE_WITH_MODULES([$1],[$2],[$3],[$4])
-
-AS_IF([test "$AS_TR_SH([with_]m4_tolower([$1]))" = "yes"],
-        [AC_DEFINE([HAVE_][$1], 1, [Enable ]m4_tolower([$1])[ support])])
-])dnl PKG_HAVE_DEFINE_WITH_MODULES
-
diff --git a/config.sub b/config.sub
index d74fb6deac..09ebc4287c 100755
--- a/config.sub
+++ b/config.sub
@@ -1121,7 +1121,7 @@
 	xscale-* | xscalee[bl]-*)
 		cpu=`echo "$cpu" | sed 's/^xscale/arm/'`
 		;;
-	arm64-*)
+	arm64-* | arm64_32-*)
 		cpu=aarch64
 		;;
 
@@ -1723,7 +1723,7 @@
 	     | hpux* | unos* | osf* | luna* | dgux* | auroraux* | solaris* \
 	     | sym* |  plan9* | psp* | sim* | xray* | os68k* | v88r* \
 	     | hiux* | abug | nacl* | netware* | windows* \
-	     | os9* | macos* | osx* | ios* \
+	     | os9* | macos* | osx* | ios* | tvos* | watchos* \
 	     | mpw* | magic* | mmixware* | mon960* | lnews* \
 	     | amigaos* | amigados* | msdos* | newsos* | unicos* | aof* \
 	     | aos* | aros* | cloudabi* | sortix* | twizzler* \
@@ -1786,6 +1786,8 @@
 		;;
 	*-eabi* | *-gnueabi*)
 		;;
+	ios*-simulator | tvos*-simulator | watchos*-simulator)
+		;;
 	-*)
 		# Blank kernel with real OS is always fine.
 		;;
diff --git a/configure b/configure
index bad619963a..93d99872fd 100755
--- a/configure
+++ b/configure
@@ -660,6 +660,8 @@
 DTRACE
 TCLTK_LIBS
 TCLTK_INCLUDES
+LIBFFI_LIB
+LIBFFI_LIBDIR
 LIBFFI_INCLUDEDIR
 PKG_CONFIG_LIBDIR
 PKG_CONFIG_PATH
@@ -793,7 +795,6 @@
 docdir
 oldincludedir
 includedir
-runstatedir
 localstatedir
 sharedstatedir
 sysconfdir
@@ -917,7 +918,6 @@
 sysconfdir='${prefix}/etc'
 sharedstatedir='${prefix}/com'
 localstatedir='${prefix}/var'
-runstatedir='${localstatedir}/run'
 includedir='${prefix}/include'
 oldincludedir='/usr/include'
 docdir='${datarootdir}/doc/${PACKAGE_TARNAME}'
@@ -1170,15 +1170,6 @@
   | -silent | --silent | --silen | --sile | --sil)
     silent=yes ;;
 
-  -runstatedir | --runstatedir | --runstatedi | --runstated \
-  | --runstate | --runstat | --runsta | --runst | --runs \
-  | --run | --ru | --r)
-    ac_prev=runstatedir ;;
-  -runstatedir=* | --runstatedir=* | --runstatedi=* | --runstated=* \
-  | --runstate=* | --runstat=* | --runsta=* | --runst=* | --runs=* \
-  | --run=* | --ru=* | --r=*)
-    runstatedir=$ac_optarg ;;
-
   -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
     ac_prev=sbindir ;;
   -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
@@ -1316,7 +1307,7 @@
 for ac_var in	exec_prefix prefix bindir sbindir libexecdir datarootdir \
 		datadir sysconfdir sharedstatedir localstatedir includedir \
 		oldincludedir docdir infodir htmldir dvidir pdfdir psdir \
-		libdir localedir mandir runstatedir
+		libdir localedir mandir
 do
   eval ac_val=\$$ac_var
   # Remove trailing slashes.
@@ -1469,7 +1460,6 @@
   --sysconfdir=DIR        read-only single-machine data [PREFIX/etc]
   --sharedstatedir=DIR    modifiable architecture-independent data [PREFIX/com]
   --localstatedir=DIR     modifiable single-machine data [PREFIX/var]
-  --runstatedir=DIR       modifiable per-process data [LOCALSTATEDIR/run]
   --libdir=DIR            object code libraries [EPREFIX/lib]
   --includedir=DIR        C header files [PREFIX/include]
   --oldincludedir=DIR     C header files for non-gcc [/usr/include]
@@ -3344,6 +3334,15 @@
 	*-*-cygwin*)
 		ac_sys_system=Cygwin
 		;;
+	*-apple-ios*)
+		ac_sys_system=iOS
+		;;
+	*-apple-tvos*)
+		ac_sys_system=tvOS
+		;;
+	*-apple-watchos*)
+		ac_sys_system=watchOS
+		;;
 	*-*-vxworks*)
 	    ac_sys_system=VxWorks
 	    ;;
@@ -3394,6 +3393,15 @@
 	*-*-cygwin*)
 		_host_cpu=
 		;;
+	*-apple-*)
+		case "$host_cpu" in
+		arm*)
+			_host_cpu=arm
+			;;
+		*)
+			_host_cpu=$host_cpu
+		esac
+		;;
 	*-*-vxworks*)
 		_host_cpu=$host_cpu
 		;;
@@ -3469,6 +3477,13 @@
     define_xopen_source=no;;
   Darwin/[12][0-9].*)
     define_xopen_source=no;;
+  # On iOS, defining _POSIX_C_SOURCE also disables platform specific features.
+  iOS/*)
+    define_xopen_source=no;;
+  tvOS/*)
+    define_xopen_source=no;;
+  watchOS/*)
+    define_xopen_source=no;;
   # On QNX 6.3.2, defining _XOPEN_SOURCE prevents netdb.h from
   # defining NI_NUMERICHOST.
   QNX/6.3.2)
@@ -5365,7 +5380,30 @@
 #elif defined(__gnu_hurd__)
         i386-gnu
 #elif defined(__APPLE__)
-        darwin
+#  include "TargetConditionals.h"
+#  if TARGET_OS_IOS
+#    if TARGET_OS_SIMULATOR
+       iphonesimulator
+#    else
+       iphoneos
+#    endif
+#  elif TARGET_OS_TV
+#    if TARGET_OS_SIMULATOR
+       appletvsimulator
+#    else
+       appletvos
+#    endif
+#  elif TARGET_OS_WATCH
+#    if TARGET_OS_SIMULATOR
+       watchsimulator
+#    else
+       watchos
+#    endif
+#  elif TARGET_OS_OSX
+     darwin
+#  else
+#    error unknown Apple platform
+#  endif
 #elif defined(__VXWORKS__)
         vxworks
 #else
@@ -5389,6 +5427,12 @@
 case $ac_sys_system in #(
   Darwin*) :
     MULTIARCH="" ;; #(
+  iOS*) :
+    MULTIARCH="" ;; #(
+  tvOS*) :
+    MULTIARCH="" ;; #(
+  watchOS*) :
+    MULTIARCH="" ;; #(
   FreeBSD*) :
     MULTIARCH="" ;; #(
   *) :
@@ -6249,11 +6293,23 @@
 fi
 
 if test "$cross_compiling" = yes; then
-    case "$READELF" in
-	readelf|:)
-	as_fn_error $? "readelf for the host is required for cross builds" "$LINENO" 5
-	;;
-    esac
+	case "$host" in
+	*-apple-ios*)
+		# readelf not required for iOS cross builds.
+        	;;
+	*-apple-tvos*)
+		# readelf not required for tvOS cross builds.
+        	;;
+	*-apple-watchos*)
+		# readelf not required for watchOS cross builds.
+        	;;
+	*)
+    		case "$READELF" in
+			readelf|:)
+			as_fn_error $? "readelf for the host is required for cross builds" "$LINENO" 5
+			;;
+    		esac
+	esac
 fi
 
 
@@ -9787,6 +9843,10 @@
 			BLDSHARED="$LDSHARED"
 		fi
 		;;
+  iOS/*|tvOS/*|watchOS/*)
+    LDSHARED='$(CC) -bundle -undefined dynamic_lookup'
+    LDCXXSHARED='$(CXX) -bundle -undefined dynamic_lookup'
+    ;;
 	Linux*|GNU*|QNX*|VxWorks*)
 		LDSHARED='$(CC) -shared'
 		LDCXXSHARED='$(CXX) -shared';;
@@ -10811,23 +10871,35 @@
     { $as_echo "$as_me:${as_lineno-$LINENO}: result: $with_system_ffi" >&5
 $as_echo "$with_system_ffi" >&6; }
 else
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-    if test "$with_system_ffi" != ""
+    if test "$ac_sys_system" = "iOS" || test "$ac_sys_system" = "tvOS" || test "$ac_sys_system" = "watchOS"
     then
-        { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: --with(out)-system-ffi is ignored on this platform" >&5
+        { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+        { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Using user-provided libffi configuration" >&5
+$as_echo "$as_me: WARNING: Using user-provided libffi configuration" >&2;}
+        LIBFFI_LIBDIR="${LIBFFI_LIBDIR}"
+        LIBFFI_LIB="${LIBFFI_LIB}"
+    else
+        { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+        if test "$with_system_ffi" != ""
+        then
+            { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: --with(out)-system-ffi is ignored on this platform" >&5
 $as_echo "$as_me: WARNING: --with(out)-system-ffi is ignored on this platform" >&2;}
+        fi
+        with_system_ffi="yes"
     fi
-    with_system_ffi="yes"
 fi
 
 if test "$with_system_ffi" = "yes" && test -n "$PKG_CONFIG"; then
     LIBFFI_INCLUDEDIR="`"$PKG_CONFIG" libffi --cflags-only-I 2>/dev/null | sed -e 's/^-I//;s/ *$//'`"
 else
-    LIBFFI_INCLUDEDIR=""
+    LIBFFI_INCLUDEDIR="${LIBFFI_INCLUDEDIR}"
 fi
 
 
+
+
 # Check for use of the system libmpdec library
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for --with-system-libmpdec" >&5
 $as_echo_n "checking for --with-system-libmpdec... " >&6; }
@@ -17742,8 +17814,8 @@
     if ! $found; then
         OPENSSL_INCLUDES=
         for ssldir in $ssldirs; do
-            { $as_echo "$as_me:${as_lineno-$LINENO}: checking for openssl/ssl.h in $ssldir" >&5
-$as_echo_n "checking for openssl/ssl.h in $ssldir... " >&6; }
+            { $as_echo "$as_me:${as_lineno-$LINENO}: checking for include/openssl/ssl.h in $ssldir" >&5
+$as_echo_n "checking for include/openssl/ssl.h in $ssldir... " >&6; }
             if test -f "$ssldir/include/openssl/ssl.h"; then
                 OPENSSL_INCLUDES="-I$ssldir/include"
                 OPENSSL_LDFLAGS="-L$ssldir/lib"
@@ -19367,7 +19439,7 @@
 echo "creating Modules/Setup.local" >&6
 if test ! -f Modules/Setup.local
 then
-	echo "# Edit this file for local setup changes" >Modules/Setup.local
+   echo "# Edit this file for local setup changes" >Modules/Setup.local
 fi
 
 echo "creating Makefile" >&6
diff --git a/configure.ac b/configure.ac
index cc69015b10..d81f17dad6 100644
--- a/configure.ac
+++ b/configure.ac
@@ -400,6 +400,15 @@
 	*-*-cygwin*)
 		ac_sys_system=Cygwin
 		;;
+	*-apple-ios*)
+		ac_sys_system=iOS
+		;;
+	*-apple-tvos*)
+		ac_sys_system=tvOS
+		;;
+	*-apple-watchos*)
+		ac_sys_system=watchOS
+		;;
 	*-*-vxworks*)
 	    ac_sys_system=VxWorks
 	    ;;
@@ -449,6 +458,15 @@
 	*-*-cygwin*)
 		_host_cpu=
 		;;
+	*-apple-*)
+		case "$host_cpu" in
+		arm*)
+			_host_cpu=arm
+			;;
+		*)
+			_host_cpu=$host_cpu
+		esac
+		;;
 	*-*-vxworks*)
 		_host_cpu=$host_cpu
 		;;
@@ -521,6 +539,13 @@
     define_xopen_source=no;;
   Darwin/@<:@[12]@:>@@<:@0-9@:>@.*)
     define_xopen_source=no;;
+  # On iOS, defining _POSIX_C_SOURCE also disables platform specific features.
+  iOS/*)
+    define_xopen_source=no;;
+  tvOS/*)
+    define_xopen_source=no;;
+  watchOS/*)
+    define_xopen_source=no;;
   # On QNX 6.3.2, defining _XOPEN_SOURCE prevents netdb.h from
   # defining NI_NUMERICHOST.
   QNX/6.3.2)
@@ -855,7 +880,30 @@
 #elif defined(__gnu_hurd__)
         i386-gnu
 #elif defined(__APPLE__)
-        darwin
+#  include "TargetConditionals.h"
+#  if TARGET_OS_IOS
+#    if TARGET_OS_SIMULATOR
+       iphonesimulator
+#    else
+       iphoneos
+#    endif
+#  elif TARGET_OS_TV
+#    if TARGET_OS_SIMULATOR
+       appletvsimulator
+#    else
+       appletvos
+#    endif
+#  elif TARGET_OS_WATCH
+#    if TARGET_OS_SIMULATOR
+       watchsimulator
+#    else
+       watchos
+#    endif
+#  elif TARGET_OS_OSX
+     darwin
+#  else
+#    error unknown Apple platform
+#  endif
 #elif defined(__VXWORKS__)
         vxworks
 #else
@@ -875,6 +923,9 @@
 AC_MSG_CHECKING([for multiarch])
 AS_CASE([$ac_sys_system],
   [Darwin*], [MULTIARCH=""],
+  [iOS*], [MULTIARCH=""],
+  [tvOS*], [MULTIARCH=""],
+  [watchOS*], [MULTIARCH=""],
   [FreeBSD*], [MULTIARCH=""],
   [MULTIARCH=$($CC --print-multiarch 2>/dev/null)]
 )
@@ -1210,11 +1261,23 @@
 
 AC_CHECK_TOOLS([READELF], [readelf], [:])
 if test "$cross_compiling" = yes; then
-    case "$READELF" in
-	readelf|:)
-	AC_MSG_ERROR([readelf for the host is required for cross builds])
-	;;
-    esac
+	case "$host" in
+	*-apple-ios*)
+		# readelf not required for iOS cross builds.
+        	;;
+	*-apple-tvos*)
+		# readelf not required for tvOS cross builds.
+        	;;
+	*-apple-watchos*)
+		# readelf not required for watchOS cross builds.
+        	;;
+	*)
+    		case "$READELF" in
+			readelf|:)
+			AC_MSG_ERROR([readelf for the host is required for cross builds])
+			;;
+    		esac
+	esac
 fi
 AC_SUBST(READELF)
 
@@ -2712,6 +2775,10 @@
 			BLDSHARED="$LDSHARED"
 		fi
 		;;
+  iOS/*|tvOS/*|watchOS/*)
+    LDSHARED='$(CC) -bundle -undefined dynamic_lookup'
+    LDCXXSHARED='$(CXX) -bundle -undefined dynamic_lookup'
+    ;;
 	Linux*|GNU*|QNX*|VxWorks*)
 		LDSHARED='$(CC) -shared'
 		LDCXXSHARED='$(CXX) -shared';;
@@ -3118,20 +3185,30 @@
     esac
     AC_MSG_RESULT($with_system_ffi)
 else
-    AC_MSG_RESULT(yes)
-    if test "$with_system_ffi" != ""
+    if test "$ac_sys_system" = "iOS" || test "$ac_sys_system" = "tvOS" || test "$ac_sys_system" = "watchOS"
     then
-        AC_MSG_WARN([--with(out)-system-ffi is ignored on this platform])
+        AC_MSG_RESULT(no)
+        AC_MSG_WARN([Using user-provided libffi configuration])
+        LIBFFI_LIBDIR="${LIBFFI_LIBDIR}"
+        LIBFFI_LIB="${LIBFFI_LIB}"
+    else
+        AC_MSG_RESULT(yes)
+        if test "$with_system_ffi" != ""
+        then
+            AC_MSG_WARN([--with(out)-system-ffi is ignored on this platform])
+        fi
+        with_system_ffi="yes"
     fi
-    with_system_ffi="yes"
 fi
 
 if test "$with_system_ffi" = "yes" && test -n "$PKG_CONFIG"; then
     LIBFFI_INCLUDEDIR="`"$PKG_CONFIG" libffi --cflags-only-I 2>/dev/null | sed -e 's/^-I//;s/ *$//'`"
 else
-    LIBFFI_INCLUDEDIR=""
+    LIBFFI_INCLUDEDIR="${LIBFFI_INCLUDEDIR}"
 fi
 AC_SUBST(LIBFFI_INCLUDEDIR)
+AC_SUBST(LIBFFI_LIBDIR)
+AC_SUBST(LIBFFI_LIB)
 
 # Check for use of the system libmpdec library
 AC_MSG_CHECKING(for --with-system-libmpdec)
@@ -6013,7 +6090,7 @@
 echo "creating Modules/Setup.local" >&AS_MESSAGE_FD
 if test ! -f Modules/Setup.local
 then
-	echo "# Edit this file for local setup changes" >Modules/Setup.local
+   echo "# Edit this file for local setup changes" >Modules/Setup.local
 fi
 
 echo "creating Makefile" >&AS_MESSAGE_FD
diff --git a/setup.py b/setup.py
index 85a2b26357..86d97d1dd8 100644
--- a/setup.py
+++ b/setup.py
@@ -84,6 +84,9 @@
 MS_WINDOWS = (HOST_PLATFORM == 'win32')
 CYGWIN = (HOST_PLATFORM == 'cygwin')
 MACOS = (HOST_PLATFORM == 'darwin')
+IOS = HOST_PLATFORM.startswith('ios-')
+TVOS = HOST_PLATFORM.startswith('tvos-')
+WATCHOS = HOST_PLATFORM.startswith('watchos-')
 AIX = (HOST_PLATFORM.startswith('aix'))
 VXWORKS = ('vxworks' in HOST_PLATFORM)
 CC = os.environ.get("CC")
@@ -163,16 +166,20 @@
     for var_name in make_vars:
         var = sysconfig.get_config_var(var_name)
         if var is not None:
-            m = re.search(r'--sysroot=([^"]\S*|"[^"]+")', var)
-            if m is not None:
-                sysroot = m.group(1).strip('"')
-                for subdir in subdirs:
-                    if os.path.isabs(subdir):
-                        subdir = subdir[1:]
-                    path = os.path.join(sysroot, subdir)
-                    if os.path.isdir(path):
-                        dirs.append(path)
-                break
+            for pattern in [
+                r'-isysroot\s*([^"]\S*|"[^"]+")',
+                r'--sysroot=([^"]\S*|"[^"]+")',
+            ]:
+                m = re.search(pattern, var)
+                if m is not None:
+                    sysroot = m.group(1).strip('"')
+                    for subdir in subdirs:
+                        if os.path.isabs(subdir):
+                            subdir = subdir[1:]
+                        path = os.path.join(sysroot, subdir)
+                        if os.path.isdir(path):
+                            dirs.append(path)
+                    break
     return dirs
 
 
@@ -2243,6 +2250,11 @@
             extra_compile_args.append('-DMACOSX')
             include_dirs.append('_ctypes/darwin')
 
+        if IOS or TVOS or WATCHOS:
+            sources.append('_ctypes/malloc_closure.c')
+            extra_compile_args.append('-DUSING_MALLOC_CLOSURE_DOT_C=1')
+            include_dirs.append('_ctypes/darwin')
+
         elif HOST_PLATFORM == 'sunos5':
             # XXX This shouldn't be necessary; it appears that some
             # of the assembler code is non-PIC (i.e. it has relocations
@@ -2272,7 +2284,8 @@
                                libraries=['m']))
 
         ffi_inc = sysconfig.get_config_var("LIBFFI_INCLUDEDIR")
-        ffi_lib = None
+        ffi_lib_dir = sysconfig.get_config_var("LIBFFI_LIBDIR")
+        ffi_lib = sysconfig.get_config_var("LIBFFI_LIB")
 
         ffi_inc_dirs = self.inc_dirs.copy()
         if MACOS:
@@ -2301,6 +2314,7 @@
             for lib_name in ('ffi', 'ffi_pic'):
                 if (self.compiler.find_library_file(self.lib_dirs, lib_name)):
                     ffi_lib = lib_name
+                    self.use_system_libffi = True
                     break
 
         if ffi_inc and ffi_lib:
@@ -2314,7 +2328,8 @@
 
             ext.include_dirs.append(ffi_inc)
             ext.libraries.append(ffi_lib)
-            self.use_system_libffi = True
+            if ffi_lib_dir:
+                ext.library_dirs.append(ffi_lib_dir)
 
         if sysconfig.get_config_var('HAVE_LIBDL'):
             # for dlopen, see bpo-32647
